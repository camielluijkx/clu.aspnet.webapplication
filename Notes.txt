[Abbreviations]

Active Server Pages (ASP)
Model-View-Controller (MVC)
Internet Information Services (IIS)
Integrated Development Environment (IDE)
Internet Service Provider (ISP)
Asynchronous JavaScript and XML (AJAX)
JavaScript Object Notation (JSON)
Extensible Markup Language (XML)
Application Program Interface (API)
File Transfer Protocol (FTP)
Secure Sockets Layer (SSL)
Test-Driven Development (TDD)
Unified Modeling Language (UML)
Logical Data Model (LDM)
Windows Communication Foundation (WCF)
Hypertext Transfer Protocol (HTTP)
Object Relational Mapping (ORM)
Language Integrated Query (LINQ)
Entity Framework (EF)


[Summary 20486C]

Module 1: Exploring ASP.NET MVC 5
	Lesson 1: Overview of Microsoft Web Technologies
		Developer Tools (Microsoft Visual Studio)
			designing, coding, and debugging any ASP.NET web application, including MVC applications
		Hosting Technologies (Microsoft Internet Information Server, Microsoft Azure)
			IIS can host any ASP.NET, PHP, or Node.js websites
		Database Technologies (Microsoft SQL Server, Microsoft Azure SQL Database)
		Code Execution Technologies (Server-Side Execution + Client-Side Execution)
		Programming Models (Web Pages, Web Forms, MVC)
			use MVC to separate server-side code into three parts:
				• MVC model defines a set of classes that represent the object types that the web application manages
				• MVC view is a component that builds the webpages that make up the web application’s user interface
				• MVC controller is a class that handles user interaction, creates and modifies model classes, and selects appropriate views
		ASP.NET API
			use classes within the System.Web namespace to rapidly implement common website functionalities:
				• Configuration (System.Web.Configuration)
				• Authentication and Authorization (System.Web.Security)
				• Caching (System.Runtime.Caching)
		Compiling ASP.NET Code (Compilation to MSIL vs Compilation to native code)
			use pre-compilation to avoid delays and to protect source code
		Client-Side Web Technologies (JavaScript, jQuery, jQuery UI, jQuery Mobile, AJAX)
		Internet Information Server Features
			IIS is tightly integrated with ASP.NET, Visual Studio 2017, and Windows Server:		
				• Deployment Protocols. The advanced Web Deploy protocol, which is built into Visual Studio 2017, automatically manages the deployment of a website with all its dependencies. Alternatively, you can use File Transfer Protocol (FTP) to deploy content.
				• Centralized Web Farm Management. When you run a large website, you can configure a load-balanced farm of many IIS servers to scale to large sizes. IIS management tools make it easy to deploy sites to all servers in the farm and manage sites after deployment.
				• High Performance Caches. You can configure ASP.NET to make optimal use of the IIS caches to accelerate responses to user requests. When IIS serves a page or other content, it can cache it in memory so that subsequent identical requests can be served faster.
				• Authentication and Security. IIS supports most common standards for authentication, including Smart Card authentication and Integrated Windows authentication. You can also use Secure Sockets Layer (SSL) to encrypt security-sensitive communications, such as logon pages and pages containing credit card numbers.
				• ASP.NET Support. IIS is a web server that fully supports ASP.NET.
				• Other Server-Side Technologies. You can host websites developed in PHP and Node.js on IIS.
			Scaling Up IIS
				• scalability
				• resilience
			Perimeter Networks
				 A perimeter network has a network segment that is protected from the Internet through a firewall that validates and permits incoming HTTP requests. A second firewall, which permits requests only from the web server, separates the perimeter network from the internal organizational network. 
			IIS Express
			Other Web Servers (Apache, nginx)
		Microsoft Azure	
			• Flexible Scaling
			• Flexible Pricing
			host (Web Apps, API Apps, Databases, Virtual Servers, Mobile Services, Media Services)
	Lesson 2: Overview of ASP.NET
		Web Pages Applications
			The Web Pages programming model has the following advantages:
				• It is simple to learn.
				• It provides precise control over the rendered HTML.
			Using a Web Pages site has some disadvantages:
				• It provides no control over URLs that appear in the Address bar.
				• Large websites require large numbers of pages, each of which must be coded individually.
				• There is no separation of business logic, input logic, and the user interface.
		Web Forms Applications
			Web Forms Controls:
				• Input controls, such as text boxes, option buttons, and check boxes.
				• Display controls, such as image boxes, image maps, and ad rotators.
				• Data display controls, such as grid views, form views, and charts.
				• Validation controls, which check data entered by the user.
				• Navigation controls, such as menus and tree views.
			Web Forms Code Files (web page + code behind)
			Binding Controls to Data
			The Web Forms programming model has the following advantages:
				• You can design your page visually by using server controls and Design View.
				• You can use a broad range of highly functional controls that encapsulate a lot of functionality.
				• You can display data without writing many lines of server-side code.
				• The user interface in the .aspx file is separated from input and business logic in the code-behind files.
			Using a Web Forms site has some disadvantages:
				• The ASP.NET Web Forms page life cycle is an abstraction layer over HTTP and can behave in unexpected ways. You must have a complete understanding of this life cycle, to write code in the correct event handlers.
				• You do not have precise control over markup generated by server-side controls.
				• Controls can add large amounts of markup and state information to the rendered HTML page. This increases the time taken to load pages.
		MVC Applications
			The MVC programming model has the following advantages:
				• Views enable the developer to take precise control of the HTML that is rendered.
				• You can use the Routing Engine to take precise control of URLs.
				• Business logic, input logic, and user interface logic are separated into Models, Controllers, and Views.
				• Unit testing techniques and Test Driven Development (TDD) are possible.
			Using an MVC site has some disadvantages:
				• MVC is potentially more complex to understand than Web Pages or Web Forms.
				• MVC forces you to separate your concerns (models, views, and controllers). Some programmers may find this challenging.
				• You cannot visually create a user interface by dragging controls onto a page.
				• You must have a full understanding of HTML, CSS, and JavaScript to develop Views.
		Shared ASP.NET Features
			• Configuration
			• Authentication
			• Membership and Roles
			• State Management
			• Caching
	Lesson 3: Introduction to ASP.NET MVC 5
		Models, Views and Controllers
			Models and Data
			Controllers and Actions
				• Controllers inherit from the System.Web.Mvc.Controller base class. 
				• Actions usually return a System.Web.Mvc.ActionResult object.
			Views and Razor
				• A view is, by default, a .cshtml or .vbhtml file that includes both HTML markup and programming code.
				• A view engine interprets view files, runs the server-side code, and renders HTML to the web browser.
				• Razor is the default view engine in ASP.NET MVC 5.
		Request Life Cycle

Module 2: Designing ASP.NET MVC 5 Web Applications
	Lesson 1: Planning in the Project Design Phase
		Project Development Methodologies
			• Waterfall Model:
				• Feasibility analysis. In this phase, planners and developers study and determine the approaches and technologies that can be used to build the software application.
				• Requirement analysis. In this phase, planners and analysts interview the users, managers, administrators, and other stakeholders of the software application to determine their needs.
				• Application design. In this phase, planners, analysts, and developers record a proposed solution.
				• Coding and unit testing. In this phase, developers create the code and test the components that make up the system individually.
				• Integration and system testing. In this phase, developers integrate the components that they have built and test the system as a whole.
				• Deployment and maintenance. In this phase, developers and administrators deploy the solution so that users can start using the software application.
			• Iterative Development Model
			• Prototyping Model
			• Agile Software Development Model:				
				• Incremental development. Software is developed in rapid cycles that build on earlier cycles. Each iteration is thoroughly tested.
				• Emphasis on people and interactions. Developers write code based on what people do in their role, rather than what the development tools are good at.
				• Emphasis on working software. Instead of writing detailed design documents for stakeholders, developers write solutions that stakeholders can evaluate at each iteration to validate if it solves a requirement.
				• Close collaboration with customers. Developers discuss with customers and stakeholders on a day-to-day basis to check requirements.
			• Extreme Programming
			• Test Driven Development
		Unified Modeling Language:
			• Behavior diagrams. These diagrams depict the behavior of users, applications, and application components.
			• Interaction diagrams. These diagrams are a subset of behavior diagrams that focus on the interactions between objects.
			• Structure diagrams. These diagrams depict the elements of an application that are independent of time. This means they do not change through the lifetime of the application.
		Gathering Requirements:
			• Functional requirements. These requirements describe how the application behaves and responds to users. Functional requirements are often called behavioral requirements. They include:
				• User interface requirements. These requirements describe how the user interacts with an application.
				• Usage requirements. These requirements describe what a user can do with the application.
				• Business requirements. These requirements describe how the application will fulfill business functions.
			• Technical requirements. These requirements describe technical features of the application and relate to availability, security, or performance. These requirements are sometimes called non-functional or non-behavioral requirements.
		Usage Scenarios and Use Cases:
			• A usage scenario is a specific real-world example, with names and suggested input values, of an interaction between the application and a user.
			• A use case is similar to a usage scenario, but is more generalized. Use cases do not include user names or input values. They describe multiple paths of an interaction, which depends on what the user provides as input or other values.
		Agile Requirements Modeling:
			• Initial requirement modeling. In the initial design phase, developers identify and record a few broad use cases in an informal manner without full details.
			• Just-in-time modeling. Before writing code that implements a use case, a developer discusses it with the relevant users. At this point, the developer adds full details to the use case. In an agile development project, developers talk to users and other stakeholders at all times, and not just at the beginning and end of the project.
			• Acceptance testing. An acceptance test is a test that the application must pass for all stakeholders to accept and sign off the application. When you identify a functional requirement, you can also specify a corresponding acceptance test that must be run to ensure that the requirements are met.
		User Stories in Extreme Programming
		Planning the Database Design:
			Logical Modeling
			Physical Database Structure:
				• Tables
				• Views
				• Stored Procedures
				• Security
			Working with Database Administrators
			Database Design in Agile Development and Extreme Programming
		Planning for Distributed Applications:
			Distributed web applications often use a layered architecture:
				• Presentation layer. Components in this layer implement the user interface and presentation logic. If you are building an MVC web application, views and controllers make up your presentation layer.
				• Business logic layer. Components in this layer implement high-level business objects such as products, or customers. If you are building an MVC web application, models make up your business logic layer.
				• Data access layer. Components in this layer implement database access operations and abstract database objects, such as tables, from business objects. For example, a product business object may include data from both the Products and StockLevels database tables. If you are building an MVC web application, models often make up both business logic and data access layers. However, with careful design and coding practices, it is possible to refactor code to separate these layers.
				• Database layer. This layer has the database itself.
			Communication Between Layers:
				• Between the browser and presentation layer web server. In any web application, the web browser, where the presentation layer runs, communicates with the web server by using HTTP. If authentication is required, it is often performed by exchanging plain text credentials. You can also use Secure Sockets Layer (SSL) to encrypt this sensitive communication.
				• Between the web server and the middle-tier server. The communication and security mechanisms used for communication between the web server and the middle-tier server depends on the technology that you use to build the business logic components:
					• Web services: If you implement business objects and data access classes as web services, the presentation layer components communicate with the web services by using HTTP. You can perform authentication by using the Kerberos protocol that is a part of Windows Integrated Authentication or by using plain text encrypted with SSL.
					• Windows Communication Foundation (WCF) services: If you implement business objects and data access classes as WCF services, you can choose between two hosting mechanisms. You can host the WCF services within IIS, in which case, HTTP is the transport mechanism and SSL is the security mechanism. You can also host the WCF services within a Windows Process Activation Service (WAS), in which case, you can use TCP, Microsoft Message Queuing (MSMQ), or named pipes as the transport mechanism.
				• Between middle-tier server and database. The middle-tier server sends T-SQL queries to the database server, which authenticates against the database by using the required credentials that are often included in the connection string.
		Planning State Management:
			In application development, the application state refers to the values and information that are maintained across multiple operations. Hypertext Transfer Protocol (HTTP) is fundamentally a stateless protocol, which indicates that it has no mechanism to retain state information across multiple page requests. However, there are many scenarios, such as the following, which require state to be preserved:
				• User preferences. Some websites enable users to specify preferences. For example, a photo sharing web application might enable users to choose a preferred size for photos. If this preference information is lost between page requests, users have to continually reapply the preference.
				• User identity. Some sites authenticate users to provide access to members-only content. If the user identity is lost between page requests, the user must re-enter the credentials for every page.
				• Shopping carts. If the content of a shopping cart is lost between page requests, the customer cannot buy anything from your web application.
			• Client-Side State Storage:
				• Cookies. Cookies are small text files that you can pass to the browser to store information. A cookie can be stored:
					• In the client computer memory, in which case, it preserves information only for a single user session.
					• On the client computer hard disk drive, in which case, it preserves information across multiple sessions.
					• Most browsers can store cookies only up to 4,096 bytes and permit only 20 cookies per website. Therefore, cookies can be used only for small quantities of data. Also, some users may disable cookies for privacy purposes, so you should not rely on cookies for critical functions.
				• Query strings. A query string is the part of the URL after the question mark and is often used to communicate form values and other data to the server. You can use the query string to preserve a small amount of data from one page request to another. All browsers support query strings, but some impose a limit of 2,083 characters on the URL length. You should not place any sensitive information in query strings because it is visible to the user, anyone observing the session, or anyone monitoring web traffic.
			• Server-Side State Storage:
				The following locations store state information in server memory:
					• TempData. This is a state storage location that you can use in MVC applications to store values between one request and another. You can store values by adding them to the TempData collection. This information is preserved for a single request only and is designed to help maintain data across a webpage redirect. For example, you can use it to pass an error message to an error page.
					• Application State. This is a state storage location that you can use to store vales for the lifetime of the application. The values stored in application state are shared among all users. You can store values by adding them to the Application collection. If the web server or the web application is restarted, the values are destroyed. The Application_Start() procedure in the Global.asax file is an appropriate place to initialize application state values. Application state is not an appropriate place to store user-specific values, such as preferences, because if you store a preference in application state, all users share the same preference, instead of having their own unique value.
					• Session state. The Session collection stores information for the lifetime of a single browser session and values stored here are specific to a single user session; they cannot be accessed by other users. By default, if the web server or the web application is restarted, the values are destroyed. However, you can configure ASP.NET to store session state in a database or state server. If you do this, session state can be preserved across restarts. Session state is available for both authenticated users and anonymous users. By default, session state uses cookies to identify users, but you can configure ASP.NET to store session state without using cookies.
				The following locations store state information in server harddisk:
					• Profile properties. If your site uses an ASP.NET profile provider, you can store user preferences in profiles. Profile properties are persisted to the membership database, so they will be kept even if the web application or web server restarts.
					• Database tables. If your site uses an underlying database, like most sites do, you can store state information in its tables. This is a good place to store large volumes of state data that cannot be placed in server memory or on the client computer. For example, if you want to store a large volume of session-specific state information, you can store a simple ID value in the Session collection and use it to query and update a record in the database.
		Planning Globalization and Localization:
			Globalization vs Localization:
				• The process by which you make a web application available in multiple languages is called globalization or internationalization. 
				• The process by which you make a web application available in a specific language and culture is called localization.
			There is an internationally-recognized set of language codes that specify a culture on the Internet: language-region.
			Using Resource Files
			Using Separate Views
	Lesson 2: Designing Models, Controllers, and Views
		Designing Models:
			A fundamental activity in the MVC design process is designing a model. Each model class within the model represents a kind of object that your application manages. You cannot plan for controllers and views until you understand the structure and design of the model.
			Identifying Model Classes and Properties
			Domain Model and Logical Data Model Diagrams
			Relationships and Aggregates (one-to-one, one-to-many, or many-to-many)
			Entity Framework:
				• Database-First. Use the Entity Framework in the database-first mode when you have a pre-existing database to work with. This may happen because you already have data from an earlier system or because a DBA has designed the database for you. You can also choose this mode if you are familiar with creating databases in a database administration tool, such as Microsoft SQL Server Management Studio. When you use this mode, you have to specify the database connection string. Entity Framework connects to the database and examines the database schema. It creates a set of classes for you to use for data access.
				• Model-First. Use Entity Framework in the model-first mode when you do not have a pre-existing database and prefer to design your model in Visual Studio. You can use the Entity Designer tool to name, configure, and link your model classes. This creates XML files that Entity Framework uses both to create model classes and to create the database with its tables and relationships.
				• Code-First. Use Entity Framework in the code-first mode when you have no pre-existing database and prefer to design your models entirely in C# code. Your code must include DBContext and DBSet objects—these correspond to the database and its tables. When you run the application for the first time, Entity Framework creates the database for you.
			Design in Agile and Extreme Programming
		Designing Controllers:
			Identify Controllers and Actions
			Design in Agile and Extreme Programming
		Designing Views:
			Views, Template Views, and Partial Views
			Creating Wireframes
			Design in Agile and Extreme Programming

Module 3: Developing ASP.NET MVC 5 Models
	Lesson 1: Creating MVC Models
		Developing Models
			Using Display and Edit Data Annotations on Properties
				The model classes usually specify three attributes for each property:
					• The name of the property, for example, Title
					• The data type of the property, for example, String
					• The access levels of the property, for example, the get and set keywords to indicate read and write access
				Additionally, by using attributes, you can supply additional metadata to describe properties to ASP.NET MVC. The MVC runtime uses this metadata to determine how to render each property in views for displaying and editing. These attributes are called display and edit annotations.
				Annotations from System.ComponentModel.DataAnnotations:
					• DisplayName
					• DataType
					• DisplayFormat
			Validating User Input with Data Annotations
				Using Validation Data Annotations:
					• Required (+ ErrorMessage)
					• Range
					• StringLength
					• RegularExpression
			Model Binders:
				• What Are Model Binders?
					A model binder is a component of an ASP.NET MVC application that creates an instance of a model class, based on the data sent in the request from the web browser. 
				• What Does a Model Binder Do?
					A model binder ensures that the right data is sent to the parameters in a controller action method.
				The Controller Action Invoker and the Default Model Binder
				How the Default Model Binder Passes Parameters
					In a default MVC application, there is only one model binder for the ControllerActionInvoker to use. This binder is an instance of the DefaultModelBinder class. The default model binder passes parameters by using the following logic:
						1. The binder examines the definition of the action that it must pass parameters to. 
						2. The binder searches for values in the request that can be passed as parameters. The binder searches for values in the following locations, in order:
							a. Form Values. If the user fills out a form and clicks a submit button, you can find parameters in the Request.Form collection.
							b. Route Values. Depending on the routes that you have defined in your web application, the model binder may be able to identify parameters in the URL. In the example URL, “45” is identified as a parameter by the default MVC route.
							c. Query Strings. If the user request includes named parameters after a question mark, you can find these parameters in the Request.QueryString collection.
							d. Files. If the user request includes uploaded files, these can be used as parameters.
					Notice that if there are form values and route values in the request, form values take precedence. Query string values are only used if there are no form values and no route values available as parameters.
			Model Extensibility:
				Custom Validation Data Annotations
					inherit from System.ComponentModel.DataAnnotations.ValidationAttribute
						example: LargerThanValidation
				Custom Model Binders
					implement System.Web.Mvc.IModelBinder 
						example: CarModelBinder
	Lesson 2: Working with Data
		Connecting to a database
			ADO.NET and Databases
				use the ADO.NET technology to access databases (System.Data)
				ADO.NET supports a wide range of databases by using different data providers:
					• Microsoft SQL Server. This is an industry-leading database server from Microsoft. ADO.NET includes the SqlClient provider for all SQL Server databases.
					• Microsoft SQL Server Express. This is a free version of SQL Server that includes a wide range of database functionality and is very flexible. Some advanced capabilities are not possible with SQL Express. The SqlClient provider is used for SQL Express.
					• OLE DB. This is a standard that many different databases adhere to. ADO.NET includes the OleDb provider for all OLE DB databases.
					• ODBC. This is another older standard that many different databases adhere to. ADO.NET includes the Odbc provider for all ODBC databases. In general, you should use an OLE DB provider, if it is available, instead of an ODBC provider.
					• You can also use third-party ADO.NET providers to access other databases.
			Cloud Databases
				Microsoft Azure SQL Database has the following advantages:
					• Databases run in Microsoft data centers with the best connectivity and reliability.
					• Microsoft guarantees up to 99% uptime.
					• You do not need to build and maintain your own database servers or employ database administrators.
					• You can scale up the databases very easily.
					• You pay only for the data that you use and distribute.
				You can use Microsoft Azure SQL Database with ADO.NET by using the SqlClient provider.
			Connecting an MVC Web Application to a Database:
				• Add a reference to the System.Data namespace.
				• Add a connection string to the Web.config file. This string specifies the provider, the location of the database, the security properties, and other properties depending on the provider. The <connectionStrings> tag must appear within the <configuration> tag, after the <configSections> tag.
		Entity Framework
			Entity Framework is an Object Relational Mapping (ORM) framework. 
			An ORM framework maps the tables and columns found in a database to objects and their properties that you can call from .NET code.
			Entity Framework Workflows:
				• Database-First. You can use the database-first workflow when you have a pre-existing database or if you prefer to create a new database by defining table, columns, views, and other database schema objects. In this workflow, Entity Framework examines the database and creates an XML file with an .edmx extension called the model file. The model file describes classes that you will be able to work with, in code. You can adjust the model by using a designer in Visual Studio and then writing code against the Entity Framework classes.
				• Model-First. You can use the model-first workflow when you do not yet have a database and you prefer to design your model by using an ORM modeling tool. In this workflow, you create the .edmx file in the Visual Studio designer and then write code against the model classes generated by the designer. When you run the application, Entity Framework creates the database tables and columns to support the model. In this workflow, Visual Studio can also create a connection string for you and insert it into Web.config, based on the database that you specify.
				• Code-First. You can use the code-first workflow if you prefer to create a model by writing .NET Framework classes. In this workflow, there is no model file. Instead, you create model classes in C# or Visual Basic. When you run the application, if the database doesn’t exist, Entity Framework creates the database.
			Code-First Workflow:
				create database and tables using repository and model classes:
					• repository class should inherit from System.Data.Entity.DbContext
					• within repository class use System.Data.Entity.DbSet<> for each model / database table
					• Entity Framework looks for a connection string with name of repository class
			Using an Entity Framework Context:
				using an Entity Framework context in a controller:
					• DbSet.Find(Object[]) Method:
						Finds an entity with the given primary key values. If an entity with the given primary key values exists in the context, then it is returned immediately without making a request to the store. Otherwise, a request is made to the store for an entity with the given primary key values and this entity, if found, is attached to the context and returned. If no entity is found in the context or the store, then null is returned.
				using Initializers to Populate Databases (code-first or model-first workflow):
					• use an initializer class to populate database with sample data which ensures that there is sample data to work with during development
					• DropCreateDatabaseAlways<TContext> Class:
						An implementation of IDatabaseInitializer that will always recreate and optionally re-seed the database the first time that a context is used in the app domain. To seed the database, create a derived class and override the Seed method.
					• DropCreateDatabaseIfModelChanges<TContext> Class:
						An implementation of IDatabaseInitializer that will DELETE, recreate, and optionally re-seed the database only if the model has changed since the database was created.
					• Database.SetInitializer(IDatabaseInitializer<TContext>) Method (Global.asax > Application_Start):
						Sets the database initializer to use for the given context type. The database initializer is called when a the given DbContext type is used to access a database for the first time. The default strategy for Code First contexts is an instance of CreateDatabaseIfNotExists<TContext>.
			Using LINQ to Entities:
				Language Integrated Query (LINQ) is a set of extensions to Visual C# and Visual Basic that enable you to write complex query expressions. 
				You can use these expressions to extract data from databases, enumerable objects, XML documents, and other data sources. 
				LINQ to Entities is the version of LINQ that works with Entity Framework.
		Data Access in Models and Repositories
			In MVC applications, you can place the data access code in the model, along with the business logic.
			However, many software architects prefer to separate these two types of code because they serve different purposes:
				• Business Logic. This code defines the objects that the web application manages, their properties, and their relationships with each other.
				• Data Access Logic. This code defines the operations necessary to persist data to a database. This includes operations to create new records, read records, update records, and delete records in database tables. A single object in the business logic layer may take data from multiple database tables. This abstraction is handled by the data access logic.
			MVC does not require you to separate business and data access logic, and you can create MVC model classes that implement both layers. This is often done in small or simple web applications with small development teams. In these scenarios, Entity Framework classes are used directly in the model classes.
			In more complex situations, you need to place the business logic in MVC model classes and place the data access logic in dedicated classes called repositories. When you take this approach, model classes are independent of the database structure and do not include code that depends on database table names, column names, or view names. This approach makes it easier to redesign the database or move to a different data store or data access technology, without the need to re-code your entire application. Using this approach, you employ the Entity Framework in your repository classes, but not in your model classes.
			How to Separate Model Classes and Repositories:
				If you do choose to separate business logic and data access logic, you must take the following steps for each model class:
					1. Define an interface for the repository class. This interface declares the methods that the repository class uses to read and write data from and to the database.
					2. Create and write code for the repository class. This class must implement all the data access methods declared in the interface.
					3. Remove all data access code from the model class.
					4. Modify the controller class to use the repository class. Instead, create an instance of the repository class and call its methods to create the model.

Module 4: Developing ASP.NET MVC 5 Controllers
	Lesson 1: Writing Controllers and Actions
		A controller is a .NET Framework class that inherits from the System.Web.Mvc.Controller base class. Controllers respond to user requests. Within a controller class, you create actions to respond to user requests. Actions are methods within a controller that return an ActionResult object. The ActionResult object is often a view that displays a response to the user request; however, it can also yield other types of results. 
		Responding to User Requests
			When an MVC web application receives a request from a web browser, the following events happen in sequence:
				1. An MvcHandler object creates a controller factory. The controller factory is the object that instantiates a controller to respond to the request. Usually, this factory is a DefaultControllerFactory object, but you can create a custom controller factory, if necessary. The MvcHandler object chooses the controller factory based on the RequestContext object, which has information about the request that the user made.
				2. The controller factory creates a Controller object, and the MvcHandler calls the Execute method in that controller.
				3. The ControllerActionInvoker examines the RequestContext object and determines the action to call in the Controller object.
				4. The ControllerActionInvoker uses a model binder to determine the values to be passed to the action as parameters.
				5. The ControllerActionInvoker runs the action. Often, the action creates a new instance of a model class, perhaps by querying the database with the parameters that the invoker passed to it. This model object is passed to a view, to display results to the user. Action methods can do many other things such as rendering views and partial views, redirecting to other websites, displaying snippets of content, or displaying other files.
			The User Request
				Users of web browsers make requests either by typing a URL into the Address bar of the browser, or by clicking a link to some address within your website. Such links can either be within your website, in which case you can control how they are rendered, or from an external website. Whether the request originates from within the website or from an external website, it can include information that controller actions can use as parameters. Consider the following examples:
					• http://www.adventure-works.com/: This URL is the home page of the website and specifies no further information.
					• http://www.adventure-works.com/photo: This URL specifies an extra value, photo. By default, the MvcHandler interprets this as the name of a controller.
					• http://www.adventure-works.com/photo/index: This URL specifies a second value, index. By default, the MvcHandler interprets this as the name of an action within the controller.
					• http://www.adventure-works.com/photo/display/1: This URL specifies a third value, 1. By default, the ControllerActionInvoker interprets this as a parameter to pass to the action method.
					• http://www.adventure-works.com/photo/display?id=1: This URL includes a query string, id=1. The model binder examines the Display actions in the Photo controller. If it finds an action with a parameter called id, it calls that action and passes 1 as a parameter.
		Writing Controller Actions
			Controller actions are public methods that return an ActionResult object. Alternatively, actions can return objects of many other classes that derive from the ActionResult class. 
			[HttpGet] default vs [HttpPost], [HttpPut], [HttpDelete]
			ModelState.IsValid property is used to check whether the user has submitted valid data
			Possible Return Classes:
				• Action methods are usually defined with the ActionResult class as the return type. ActionResult is a base class, and you can use a range of derived classes to return different responses to the web browser.
				• Controller actions usually return a view and pass a model class to it, for display. You can create an action that calls the View() helper, and creates and returns a ViewResult object. The View() helper is available when you derive from the base Controller class.
				• Alternatively, you can return an HTTP error (HttpNotFound()).
				• To return files, you can use the File() helper to return a FileContentResult object.
				• Other possible action results include:
					• PartialViewResult. You can use this action to generate a section of an HTML page, but not a complete HTML page. Partial views can be re-used in many views throughout a web application.
					• RedirectToRouteResult. You can use this action result to redirect the web browser to another action method or another route.
					• RedirectResult. You can use this action result to redirect to a specific URL, either inside your web application or to an external location.
					• ContentResult. You can use this action result to return text to the web browser. You can return plain text, XML, a comma-separated table, or other text formats. This text can be rendered in the web browser or parsed with client-side code.
			Child Actions
				When an action returns a complete view, MVC sends a new complete webpage to the web browser for display. Sometimes, you may want to call an action from within a view, to return a piece of content for display within a webpage. A child action is an action method that can return a small piece of content in this manner. The FileContentResult is often a good example of a child action, because the image returned usually forms part of a webpage. Partial views also support child actions.
				To declare an action method as a child action, you can use the [ChildActionOnly] annotation. This annotation ensures that the action method can be called only from within a view by using the Html.Action() helper. Using this method, you can prevent a user from calling the child action directly by typing the correct URL into the Address bar.
		Using Parameters
			The ControllerActionInvoker and the DefaultModelBinder classes obtain parameters from a user request and pass them to action methods. The DefaultModelBinder can locate parameters in a posted form, the routing values, the query string, or in the posted files. If the model binder finds a parameter in the action method that matches the name and type of a parameter from the request, the action method is called and the parameter is passed from the request. This arrangement enables you to obtain and use parameters in your actions.
		Passing Information to Views
			Using The ViewBag
				The ViewBag is a dynamic object that is part of the base controller class. Because it is a dynamic object, you can add properties that are of any type to it, in the action method. In the view, you can use the ViewBag object to obtain the values added in the action.
			Using The ViewData Dictionary
				The ViewBag object was added to MVC in version 3. In the earlier versions, you could pass extra data to views by using the ViewData dictionary. This feature is still available in MVC 5 for backward compatibility and for developers who prefer to use dictionary objects.
				ViewBag is a dynamic wrapper above the ViewData dictionary. This means that you could save a value in a controller action by using ViewBag and read the same value back out by using ViewData.
		What Are Controller Factories?
			A controller factory is an MVC component that instantiates the controller classes that you create. 
			How the DefaultControllerFactory Class Locates a Controller Class
				The DefaultControllerFactory class identifies controller classes by using the following criteria:
					• The class scope must be public.	
					• The class must not be marked as abstract.
					• The class must not take generic parameters.
					• The class must have a name that ends with Controller.
					• The class must implement the IController interface.
				When the MVC web application starts, DefaultControllerFactory creates a list of all the classes in the application that satisfy these criteria. This list helps to create the correct controller rapidly. To write a controller, you must ensure that all the above mentioned criteria are implemented. Usually, you meet the IController interface criterion by inheriting from the base Controller class.
				By default, the DefaultControllerFactory mandates all controller classes to end with the word Controller. 
			Creating a Custom Controller Factory:
				• To modify the criteria for selecting controllers. The criteria described earlier are suitable for most web applications, but sometimes, you may want to change them. For example, you may not want to name controllers with Controller at the end, or you may want to add extra criteria of your own.
				• To support direct injection for testing. Direct injection is a programming technique that lets you specify classes at run time, instead of specifying classes when writing code. This is helpful for unit testing because you can inject a test class with mock data, instead of real data. The DefaultControllerFactory class does not support direct injection.
				You must implement the CreateController, GetControllerSessionBehavior, and ReleaseController methods for any custom controller factory you create.
				Registering a Custom Controller Factory (Global.asax > Application_Start):
					• ControllerBuilder.SetControllerFactory Method:
						Sets the controller factory by using the specified type.
					• example: CustomControllerFactory
	Lesson 2: Writing Action Filters
		What Are Filters?
			Filters are MVC classes that you can use to manage cross-cutting concerns in your web application. You can apply a filter to a controller action by annotating the action method with the appropriate attribute. 
			You can also apply a filter to every action in a controller by annotating the controller class with the attribute.
		Filter Types
			Filter Type		Interface				Default Class				Description
			Authorization	IAuthorizationFilter	AuthorizeAttribute			Runs before any other filter and before the code in the action method. Used to check a user’s access rights for the action.
			Action			IActionFilter			ActionFilterAttribute		Runs before and after the code in the action method.
			Result			IResultFilter			ActionFilterAttribute		Runs before and after a result is returned from an action method.
			Exception		IExceptionFilter		HandleErrorAttribute		Runs only if the action method or another filter throws an exception. Used to handle errors.
		Creating and Using Action Filters
			If you have a cross-cutting concern in your web application, you can implement it by creating a custom action filter or a custom result filter. You can create custom filters by implementing the IActionFilter interface or the IResultFilter interface. However, the ActionFilterAttribute base class implements both the IActionFilter and IResultFilter interfaces for you. By deriving your filter from the ActionFilterAttribute class, you can create a single filter that can run code both before and after the action runs, and both before and after the result is returned.
		Using a Custom Action Filter	
			example: SimpleActionFilter

Module 5: Developing ASP.NET MVC 5 Views
	Lesson 1: Creating Views with Razor Syntax
		TODO
	Lesson 2: Using HTML Helpers
		TODO
	Lesson 3: Re-using Code in Views
		TODO

Module 6: Testing and Debugging ASP.NET MVC 5 Web Applications
	Lesson 1: Unit Testing MVC Componwents
		TODO
	Lesson 2: Implementing an Exception handling Strategy
		TODO

	unit testing a model 
	fake and real repository
	unit testing a controller
	controller exception handling (OnException + HandleError)
	custom application error handling (return status code) 

Module 7: Structuring ASP.NET MVC 5 Web Applications
	Lesson 1: Analyzing Information Structure
		TODO
	Lesson 2: Configuring Routes
		TODO
	Lesson 3: Creating a Navigation Structure
		TODO

Module 8: Applying Styles to ASP.NET MVC 5 Web Applications
	Lesson 1: Using Layouts
		What are layouts?
			 Layouts are also called template views. Layouts enable you to define a common style template, and then apply it to all the views in a web application. The functionality of layouts is similar to that of the master page in a traditional ASP.NET web application. You can use layouts to define the content layout or logic that is shared across views.
			You can define multiple layouts in an ASP.NET MVC 5 application, and each layout can have multiple sections. You can define these sections anywhere in the layout file, even in the <head> section of the HTML. Sections enable you to output dynamic content to multiple, non-contiguous, regions of the final response.
		Creating a Layout
			store layout files in \Views\Shared folder
			@RenderBody() in layout file is used to render content of a child view:
				• any content that is not in a @section will be rendered by RenderBody
			@RenderSection() in layout file is used to render content that is different from RenderBody():
				• designate content to be rendered at RenderSection() using a @section declaration
				• by default, Sections are required, meaning each child view must define the section
				• pass required: false to designate that the section is optional
		Linking Views and Layouts
			_ViewStart.cshtml runs before all the other views in the web application:
				• primary purpose of _ViewStart is to set values that all the other views will have to use
				• ViewBag can be used to pass information between view and layout
				• ViewStart links layout file
	Lesson 2: Applying CSS Styles to an MVC Application
		Importing Styles into an MVC Web Application
			use CSS to style web application (external CSS file, inline CSS, and CSS code block in HTML):
				• <link href="~/Views/Shared/StyleSheet1.css" rel="stylesheet" type="text/css" />
		CSS class selector: 
			.menu
			{
				font-weight:bold;
			}
			<p class="menu">some menu</p>
		CSS id selector:
			#menu
			{
				font-size:16px;
			}
			<p id="menu">some menu</p>
	Lesson 3: Creating an Adaptive User Interface
		The HTML5 Viewport Attribute
			use viewport attribute for adaptive rendering:
				• customize web application to display differently, based on the capabilities of web browser or device
				• <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
				• device-width, device-height, initial-scale, minimum-scale, maximum-scale, user-scalable
		CSS Media Queries
			use CSS Media Queries to allow conditional application of CSS styles, based on the device conditions or browser capabilities:
				@media only screen and (max-width: 500px) {
					header{
					  float: none;
					}
				  }
			<link rel="stylesheet" type="text/css" href="smallscreen.css" media="only screen and (max-width: 500px)" />
		MVC 5 Templates and Mobile-Specific Views
			ASP.NET MVC 5 web application analyses the request for views with the naming convention [view].mobile.cshtml when received from a mobile browser
			check UserAgent string to create custom devive / browser specific views

Module 9: Building Responsive Pages in ASP.NET MVC 5 Web Applications
	Lesson 1: Using AJAX and Partial Page Updates
		TODO
	Lesson 2: Implementing a Caching Strategy
		TODO

Module 10: Using JavaScript and jQuery for Responsive MVC 5 Web Applications
	Lesson 1: Rendering and Executing JavaScript Code
		TODO
	Lesson 2: Using jQuery and jQueryUI
		TODO

Module 11: Controlling Access to ASP.NET MVC 5 Web Applications
	Lesson 1: Implementing Authentication and Authorization
		TODO
	Lesson 2: Assigning Roles and Membership
		TODO

Module 12: Building a Resilient ASP.NET MVC 5 Web Application
	Lesson 1: Developing Secure Sites
		TODO
	Lesson 2: State Management
		TODO

Module 13: Implementing Web APIs in ASP.NET MVC 5 Web Applications
	Lesson 1: Developing a Web API
		TODO
	Lesson 2: Calling a Web API
		TODO

Module 14: Handling Requests in ASP.NET MVC 5 Web Applications
	Lesson 1: Using HTTP Modules and HTTP Handlers
		TODO
	Lesson 2: Using Web Sockets
		TODO

Module 15: Deploying ASP.NET MVC 5 Web Applications
	Lesson 1: Deploying a Web Application
		TODO
	Lesson 2: Deploying an ASP.NET MVC 5 Web Application
		TODO


[Summary 20486D]

TODO