[Abbreviations]

Internet Information Services (IIS)
Integrated Development Environment (IDE)
Model-View-Controller (MVC)
Internet Service Provider (ISP)
Asynchronous JavaScript and XML (AJAX)
Single Page Application (SPA)
Representational State Transfer (REST)
Extensible Markup Language (XML)
JavaScript Object Notation (JSON)
Transport Layer Security (TLS)
Test Driven Development (TDD)
Application Programming Interface (API)
Create, Read, Update and Delete (CRUD)
Command Line Integration (CLI)
Entity Framework (EF)


[Summary 20486D]

Module 1: Exploring ASP.NET Core MVC
	Lesson 1: Overview of Microsoft Web Technologies
		Introduction to Microsoft Web Technologies:
			Developer Tools:
				• Visual Studio
				• Visual Studio Code
			Hosting Technologies:
				• Web Server:
					• Microsoft Internet Information Services
					• Microsoft Azure
				• Database Server:
					• Microsoft SQL Server
					• Microsoft Azure SQL Database
			Code Execution Technologies:
				• Server-Side Execution (on web server)
				• Client-Side Execution (in web browser)
		Overview of ASP.NET:
			Programming Models:
				• Web Pages (ASP.NET 4.x only)
				• Web Forms (ASP.NET 4.x only)
				• MVC (both ASP.NET Core and ASP.NET 4.x):
					• Model: An MVC model defines a set of classes that represent the object types that the web application manages.
					• Controller: An MVC controller is a class that handles user interaction, creates and modifies model classes, and selects appropriate views.
					• View: An MVC view is a component that builds the web pages that make up the web application’s user interface. Controllers often pass an instance of a model class to a view. The view displays properties of the model class.
					MVC versus Web Pages / Web Forms: separation of concerns, improves testability, more control over generated HTML	
				• Razor Pages (ASP.NET Core only)
				• Web API (both ASP.NET Core and ASP.NET 4.x):
					• Controller: A Web API Controller is a class that handles the client request that was sent to the server. It accesses the database, retrieves information, updates the database, if needed, and returns the HTTP response including a status code that indicates whether the action succeeded and the data, if needed.
					• Model: As With MVC, it is a set of classes that represent the object types that the web application manages.
					• Client: The client sends requests to the server to run specific actions in the Web API Controller. On the server side, you create an interface that consists of functions that can be accessed via HTTP. Those calls are sent from the client to the server to retrieve specific information and perform read-write operations.
		Client-Side Web Technologies:
			JavaScript
			jQuery: Provides elegant functions for interacting with the HTML elements on your page and with CSS styles.
			AJAX
			Angular (Typescript, Transpiling, Client-Side Component-Based Framework)
			React (Component-Based Library)
		Hosting Technologies:
			Internet Information Services Features:
				• Deployment Protocols
				• Centralized Web Farm Management
				• High-Performance Caches
				• Authentication and Security
				• ASP.NET Support
				• Other Server-Side Technologies
			Scaling Up IIS:
				• scalability
				• resilience
			Perimeter Networks:
				A perimeter network has a network segment that is protected from the internet through a firewall that validates and permits incoming HTTP requests. A second firewall, which permits requests only from the web server, separates the perimeter network from the internal organizational network. 
			IIS Express
			Other Web Servers (Apache, NGINX)
			Microsoft Azure:
				• Flexible Scaling
				• Flexible Pricing
				• Worldwide presence
				• First-class security and reliability
				Hosting with Azure: Web Apps, Databases, Virtual Machines, Mobile Apps, Media Services
	Lesson 2: Overview of ASP.NET 4.x
		Overview of Web Pages:
			The @ symbol is used to distinguish server-side code from HTML and JavaScript. When users request the page, the ASP.NET 4.x runtime compiles and runs the server-side code to render HTML and returns that HTML to the web browser for display.
			The Web Pages programming model has the following advantages:
				• It is simple to learn.
				• It provides precise control over the rendered HTML.
			Using a Web Pages site has some disadvantages:
				• It provides no control over URLs that appear in the address bar.
				• Large websites require large numbers of pages, each of which must be coded individually.
				• There is no separation of business logic, input logic, and the user interface.
		Overview of Web Forms:
			ASP.NET 4.x provides a wide variety of highly-functional controls that you assemble on Web Forms:
				• Input controls, such as text boxes, option buttons, and check boxes.
				• Display controls, such as image boxes, image maps, and ad rotators.
				• Data display controls, such as grid views, form views, and charts.
				• Validation controls, which check data entered by the user.
				• Navigation controls, such as menus and tree views.
			Web Forms Code Files:
				• page markup and code-behind file (example Default.aspx + Default.aspx.cs)
				• control markup and code-behind file (example CustomControl.ascx + CustomControl.ascx.cs)
			Binding Controls to Data:
				bind controls to data sources
			The Web Forms programming model has the following advantages:
				• You can design your page visually by using server controls and the Design view.
				• You can use a broad range of highly functional controls that encapsulate a lot of functionality.
				• You can display data without writing many lines of server-side code.
				• The user interface in the .aspx file is separated from input and business logic in the code-behind files.
			Using a Web Forms site has some disadvantages:
				• The page lifecycle is an abstraction layer over HTTP and can behave in unexpected ways. You must have a complete understanding of this life cycle, to write code in the correct event handlers.
				• You do not have precise control over the markup generated by the server-side controls.
				• Controls can add large amounts of markup and state information to the rendered HTML page. This increases the time taken to load pages.
		Overview of MVC:
			Strong separation of business logic, data access code, and the user interface into models, controllers, and views.
			Models:
				A model contains application business logic, validation, and database access logic. Each website presents information about different kinds of objects to site visitors. 
			Views:
				Views are markup pages that store both HTML and C# code in .cshtml files. This means that they are like Web Pages, but they include only user interface code. Other logic is separated into models and controllers.
			Controllers:
				Controllers respond to user actions, load data from a model, and pass it to a view so that it will render a webpage.
				Controllers are .NET classes that inherit from the System.Web.Mvc.Controller class and store code in .cs files.
				The MVC programming model has the following advantages:
					• Views enable the developer to take precise control of the HTML that is rendered.
					• You can use the Routing engine to take precise control of URLs.
					• Business logic, input logic, and user interface logic are separated into models, controllers, and views.
					• Unit testing techniques and Test Driven Development (TDD) are possible.
				Using an MVC site has some disadvantages:
					• MVC is potentially more complex to understand than Web Pages or Web Forms.
					• MVC forces you to separate your concerns (models, views, and controllers). Some programmers may find this challenging.
					• You cannot visually create a user interface by dragging controls onto a page.
					• You must have a full understanding of HTML, CSS, and JavaScript to develop views.
		Shared ASP.NET 4.x Features:
			The ASP.NET 4.x API:
				• Configuration:
					• Using the Web.config files, you can configure your web application, regardless of the programming model. The Web.config files are XML files with specific tags and attributes that the ASP.NET 4.x runtime accepts.
					• In code, you can access the configuration through the System.Web.Configuration namespace.
				• Authentication and Authorization:
					• You can use ASP.NET 4.x membership providers to authenticate and authorize users and restrict access to content. 
					• You can also build pages that enable users to register a new account, reset a password, recover a lost password, or perform other account management tasks. 
					• Membership providers belong to the System.Web.Security namespace.
				• Caching:
					• You can use caching to mitigate this delay. ASP.NET 4.x caches a rendered page in memory so that it can return the same page to subsequent user requests without having to render it again from the start. 
					• In a similar manner, .NET Framework objects can also be cached. 
					• You can access cached pages by using the System.Runtime.Caching namespace and configure the caches in Web.config.
			Compiling ASP.NET Code:
				Because ASP.NET 4.x server-side code uses .NET Framework, you must write code in a .NET managed programming language such as C# or Visual Basic. Before running the code, it must be compiled into native code so that the server CPU can process it. 
				This is a two-stage process:
					1. Compilation to MSIL. When you build a website in Visual Studio, the ASP.NET 4.x compiler creates .dll files with all the code compiled into Microsoft Intermediate Language (MSIL). This code is both independent of the language you used to write the application and the CPU architecture of the server.
					2. Compilation to native code. When a page is requested for the first time, the Common Language Runtime compiles MSIL into native code for the server CPU.
				This two-stage compilation process enables components written in different languages to work together and enables many errors to be detected at build time. 
				When you use the default compilation model, delays can arise when the first user requests a page. This is because ASP.NET 4.x must compile the page before serving it to the browser. To avoid such delays and to protect source code, use pre-compilation. When you pre-compile a site, all the ASP.NET 4.x files, including controllers, views, and models, are compiled into a single .dll file.
				Configuration:
					When you configure an ASP.NET 4.x site, you can control how errors are handled, how the site connects to databases, how user input is validated, and many other settings. You can configure ASP.NET 4.x sites by creating and editing the Web.config files. The Web.config file in the root folder of your site configures the entire site, but you can override this configuration at lower levels by creating Web.config files in sub-folders.
					Web.config files are XML files with a set of elements and attributes that the ASP.NET runtime accepts.
					If you need to access configuration values at runtime in your server-side .NET code, you can use the System.Web.Configuration namespace.
				Authentication:
					ASP.NET 4.x supports several mechanisms for authentication. 
					Integrated Windows Authentication mechanism uses your Windows user account to identify you. 
					Forms Authentication is supported by many browsers and it can be configured to check credentials against a database, directory service, or other user account stores.
				Membership and Roles:
					In ASP.NET 4.x, a membership provider is a component that implements user account management features. Several membership providers are supported by ASP.NET 4.x, such as the SQL membership provider, which uses a SQL database to store user accounts. You can also create a custom membership provider, inheriting from one of the default providers if you have unique requirements.
					When you have more than a few users, you may want to group them into roles with different levels of access. ASP.NET 4.x role providers enable you to create and populate roles with the minimum of custom code.
					You can enable access to pages on your website for individual user accounts or for all members of a role. This process is known as authorization.
				State Management:
					Web servers and web browsers communicate through HTTP. This is a stateless protocol in which each request is separate from requests before and after it. Any values from previous requests are not automatically remembered.
					However, when you build a web application, you must frequently preserve values across multiple page requests. ASP.NET 4.x provides several locations where you can store such values or state information across multiple requests.
				Caching:
					ASP.NET 4.x runtime on web server might run C# code that perform complex and time-consuming operations. It may run multiple queries against a database or call services on remote servers. You can mitigate these time delays by using ASP.NET 4.x caches.
					You can use the ASP.NET 4.x page cache to store the rendered version of a commonly requested page in the memory of the web server.
		Overview of Web API:
			Web API is an API that exists over the web and can be accessed using the HTTP protocol.
			Web API also allows you to implement REST services in your application and with that reduce application overhead and limit the data that is transmitted between client and server systems. 
			Web API allows you to call methods it exposes by using the server-side or client-side code and it allows you to implement REST-style Web APIs in your application.
			Call a Web API using AJAX:
				• JavaScript. Allows you to perform AJAX calls using the XMLHttpRequest object or the fetch method.
				• jQuery. Simplifies the process of writing AJAX calls by using the $.ajax method or other methods available in jQuery such as $.get or $.post.
				• Angular. Has dedicated objects for performing AJAX calls.
			The Web API programming model has the following advantages:	
				• Helps in creating RESTful APIs.
				• Enables external systems to use your application's business logic and features.
				• Can be accessed by various HTTP clients such as Windows, Android, IOs, and more.
				• Helps obtain data in different formats such as JSON, XML, and custom formats.
				• Supports create, read, update and delete (CRUD) actions since it works with HTTP verbs such as GET, POST, PUT, and DELETE.
				• Is ideal for mobile application integration.
			Using Web API has some disadvantages:
				• With Web API you have a complete separation between server-side code and client-side code. For some programmers, this is an advantage, but others may find this challenging and hard to understand.
				• The data returned from Web API usually is not indexed by search engines such as Google, more work needs to be done to make it crawlable.
	Lesson 3: Introduction to ASP.NET Core MVC
		Introduction to ASP.NET Core:
			ASP.NET Core is a cross-platform, open-source framework that allows you to create and host dynamic, powerful, and extensible web-based applications. With ASP.NET Core you can develop on various platforms – Windows, macOS, and Linux, deploy your application to the cloud, and create services and mobile backends.
			Why should you use ASP.NET Core?
				ASP.NET Core is a redesign of ASP.NET 4.x and it brings in many architectural shifts. ASP.NET Core is much leaner and modular than ASP.NET 4.x and has many changes within it.
				ASP.NET Core includes three main programming models that can help you to develop your applications smoothly:
					• MVC: 
						When you build a website using ASP.NET Core MVC, you separate your code into three parts: model, view, and controller. This separation of model, view, and controller code ensures that MVC applications have a logical structure, even for the most complex sites. It also improves the testability of the application.
					• Razor Pages:
						While in MVC we have a controller that receive requests, a model and a view that generates the response, with Razor Pages it is different. The request goes straight to a page that is generally located in the Pages folder.
						Each Razor Page file has an accompanying .cshtml.cs file that contains all the methods, model handlers, and logic. It contains a class that inherits from PageModel that will initialize the model inside the OnGet method. The OnGet method is also the place to get data from the database. Each public property inside the model can be displayed on the page using Razor syntax.
						What makes it different is the @page directive that must be at the first line of the .cshtml file. @page converts the file into a Razor Page, which means that it handles requests directly without going through a controller like in the MVC programming model.
						Razor syntax can be used inside Razor Pages. It allows you to insert the properties from the model and other sources into the HTML markup. Razor syntax starts with @ character. When you want to display properties from the model inside the HTML markup, you will use @model. @model will have a reference to the properties you initialized inside the OnGet method.
						The main difference between Razor Pages and MVC:
							In Razor Pages, the model and the controller are included in the Razor Pages classes and the request goes straight to the page. On the other hand, MVC programming model separates the code into models, views, and controllers.
					• Web API:
						• Controller. A Web API controller is a class that handles the client request that was sent to the server. It accesses the database, retrieves information, updates the database, if needed, and returns the HTTP response, including status code that indicates whether the action succeeded and data, if needed.
						• Model. As with MVC, it is a set of classes that represent the object types that the web application manages.
						• Client. The client sends requests to the server to run specific actions in the Web API controller. On the server side, there is an interface that consists of functions that can be accessed via HTTP. Those calls are sent from the client to the server to retrieve specific information and perform read-write operations.
		Choose between .NET Core and .NET Framework:
			.NET Standard:
				.NET Standard is a formal specification of the .NET APIs. It is intended to be available on all .NET implementations and its goal is to create a unification of the .NET ecosystem. It enables you to create code that is portable across all .NET implementations. Each .NET implementation is targeting a specific version of .NET Standard.
				A higher version number means that the previous versions are also supported but it has some extensions.
			When to use .NET Core for your application?
				You want your code to work cross-platform
				You want to create microservices
					In microservices architecture, the services layer is broken down into multiple independent components. A microservices architecture also allows you to create a mix of technologies across a service boundary.
				You want to use Docker containers (cross-platform, smaller size)
				You want to achieve a high-performing scalable system
			When to use .NET Framework for your application?
				You want to extend an existing application that uses .NET Framework (extend instead of migrate)
				You want to use NuGet packages or third-party .NET libraries that are not supported in .NET Core (not yet or not compatible)
				You want to use .NET technologies that aren't supported in .NET Core
				You want to use a platform that doesn’t support .NET Core.
		Models, Views, and Controllers:
			Models represent data and the accompanying business logic. Controllers interact with user requests and implement input logic. Views build the user interface.
			Models and Data:
				A model is a .NET class that represents an object handled by your website.
				Like any other .NET classes, model classes can include a constructor, which is a procedure that runs when a new instance of that class is created. You can also include other procedures, if necessary. These procedures encapsulate the business logic. 
				In an MVC application, the model includes code that reads and writes database records. ASP.NET Core MVC works with many different data access frameworks.
			Controllers and Actions:
				A controller is a .NET class that responds to web browser requests in an MVC application. There is usually one controller class for each model class. Controllers include actions, which are methods that run in response to a user request. 
				Controllers inherit from the Microsoft.AspNetCore.Mvc.Controller base class. Actions usually return an object that implements the Microsoft.AspNetCore.Mvc.IActionResult interface.
			Views and Razor:
				A view is a .cshtml file that includes both the HTML markup and programming code. A view engine interprets the view files, runs the server-side code, and renders HTML to the web browser. Razor is the default view engine in ASP.NET Core MVC.
				@ symbol delimits server-side code
			Request Life Cycle:
				The Request life cycle comprises a series of events that happen when a web request is processed.

Module 2: Designing ASP.NET Core MVC Web Applications
	Lesson 1: Planning in the Project Design Phase
		TODO
	Lesson 2: Designing Models, Controllers and Views
		TODO

Module 3: Configure Middleware and Services in ASP.NET Core
	Lesson 1: Configuring Middleware
		TODO
	Lesson 2: Configuring Services
		TODO

Module 4: Developing Controllers
	Lesson 1: Writing Controllers and Actions
		TODO
	Lesson 2: Configuring Routes
		TODO
	Lesson 3: Writing Action Filters
		TODO

Module 5: Developing Views
	Lesson 1: Creating Views with Razor Syntax
		TODO
	Lesson 2: Using HTML Helpers and Tag Helpers
		TODO
	Lesson 3: Reusing Code in Views
		TODO

Module 6: Developing Models
	Lesson 1: Creating MVC Models
		TODO
	Lesson 2: Working with Forms
		TODO
	Lesson 3: Validating MVC Application
		TODO

Module 7: Using Entity Framework Core in ASP.NET Core
	Lesson 1: Introduction to Entity Framework Core
		TODO
	Lesson 2: Working with Entity Framework Core
		TODO
	Lesson 3: Using Entity Framework Core in ASP.NET Core
		TODO

Module 8: Using Layouts, CSS and JavaScript in ASP.NET Core MVC
	Lesson 1: Using Layouts
		TODO
	Lesson 2: Using CSS and JavaScript
		TODO
	Lesson 3: Using jQuery
		TODO

Module 9: Client-Side Development
	Lesson 1: Applying Styles
		TODO
	Lesson 2: Using Task Runners
		TODO
	Lesson 3: Responsive Design
		TODO

Module 10: Testing and Troubleshooting
	Lesson 1: Testing MVC Applications
		TODO
	Lesson 2: Implementing an Exception Handling Strategy
		TODO
	Lesson 3: Logging MVC Applications
		TODO

Module 11: Managing Security
	Lesson 1: Authentication in ASP.NET Core
		TODO
	Lesson 2: Authorization in ASP.NET Core
		TODO
	Lesson 3: Defending from Attacks
		TODO

Module 12: Performance and Communication
	Lesson 1: Implementing a Caching Strategy
		TODO
	Lesson 2: Managing State
		TODO
	Lesson 3: Two-Way Communication
		TODO

Module 13: Implementing Web APIs
	Lesson 1: Introducing Web APIs
		TODO
	Lesson 2: Developing a Web API
		TODO
	Lesson 3: Calling a Web API
		TODO

Module 14: Hosting and Deployment
	Lesson 1: On-Premises Hosting and Deployment
		TODO
	Lesson 2: Deployment to Microsoft Azure
		TODO
	Lesson 3: Microsoft Azure Fundamentals
		TODO