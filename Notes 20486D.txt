[Abbreviations]

Internet Information Services (IIS)
Integrated Development Environment (IDE)
Model-View-Controller (MVC)
Internet Service Provider (ISP)
Asynchronous JavaScript and XML (AJAX)
Single Page Application (SPA)
Representational State Transfer (REST)
Extensible Markup Language (XML)
JavaScript Object Notation (JSON)
Transport Layer Security (TLS)
Test Driven Development (TDD)
Application Programming Interface (API)
Create, Read, Update and Delete (CRUD)
Command Line Integration (CLI)
Object-Relational Mapping (ORM)
Entity Framework (EF)
Extreme Programming (XP)
Unified Modeling Language (UML)
Logical Data Model (LDM)
Database Administrator (DBA)
Hypertext Transfer Protocol (HTTP)
Secure Sockets Layer (SSL)
Windows Communication Foundation (WCF)
Language-Integrated Query (LINQ)
 Globally Unique Identifier (GUID)
 Dependency Injection (DI)


[Summary 20486D]

Module 1: Exploring ASP.NET Core MVC
	Lesson 1: Overview of Microsoft Web Technologies
		Introduction to Microsoft Web Technologies:
			Developer Tools:
				• Visual Studio
				• Visual Studio Code
			Hosting Technologies:
				• Web Server:
					• Microsoft Internet Information Services
					• Microsoft Azure
				• Database Server:
					• Microsoft SQL Server
					• Microsoft Azure SQL Database
			Code Execution Technologies:
				• Server-Side Execution (on web server)
				• Client-Side Execution (in web browser)
		Overview of ASP.NET:
			Programming Models:
				• Web Pages (ASP.NET 4.x only)
				• Web Forms (ASP.NET 4.x only)
				• MVC (both ASP.NET Core and ASP.NET 4.x):
					• Model: An MVC model defines a set of classes that represent the object types that the web application manages.
					• Controller: An MVC controller is a class that handles user interaction, creates and modifies model classes, and selects appropriate views.
					• View: An MVC view is a component that builds the web pages that make up the web application’s user interface. Controllers often pass an instance of a model class to a view. The view displays properties of the model class.
					MVC versus Web Pages / Web Forms: separation of concerns, improves testability, more control over generated HTML	
				• Razor Pages (ASP.NET Core only)
				• Web API (both ASP.NET Core and ASP.NET 4.x):
					• Controller: A Web API Controller is a class that handles the client request that was sent to the server. It accesses the database, retrieves information, updates the database, if needed, and returns the HTTP response including a status code that indicates whether the action succeeded and the data, if needed.
					• Model: As With MVC, it is a set of classes that represent the object types that the web application manages.
					• Client: The client sends requests to the server to run specific actions in the Web API Controller. On the server side, you create an interface that consists of functions that can be accessed via HTTP. Those calls are sent from the client to the server to retrieve specific information and perform read-write operations.
		Client-Side Web Technologies:
			JavaScript
			jQuery: Provides elegant functions for interacting with the HTML elements on your page and with CSS styles.
			AJAX
			Angular (Typescript, Transpiling, Client-Side Component-Based Framework)
			React (Component-Based Library)
		Hosting Technologies:
			Internet Information Services Features:
				• Deployment Protocols
				• Centralized Web Farm Management
				• High-Performance Caches
				• Authentication and Security
				• ASP.NET Support
				• Other Server-Side Technologies
			Scaling Up IIS:
				• scalability
				• resilience
			Perimeter Networks:
				A perimeter network has a network segment that is protected from the internet through a firewall that validates and permits incoming HTTP requests. A second firewall, which permits requests only from the web server, separates the perimeter network from the internal organizational network. 
			IIS Express
			Other Web Servers (Apache, NGINX)
			Microsoft Azure:
				• Flexible Scaling
				• Flexible Pricing
				• Worldwide presence
				• First-class security and reliability
				Hosting with Azure: Web Apps, Databases, Virtual Machines, Mobile Apps, Media Services
	Lesson 2: Overview of ASP.NET 4.x
		Overview of Web Pages:
			The @ symbol is used to distinguish server-side code from HTML and JavaScript. When users request the page, the ASP.NET 4.x runtime compiles and runs the server-side code to render HTML and returns that HTML to the web browser for display.
			The Web Pages programming model has the following advantages:
				• It is simple to learn.
				• It provides precise control over the rendered HTML.
			Using a Web Pages site has some disadvantages:
				• It provides no control over URLs that appear in the address bar.
				• Large websites require large numbers of pages, each of which must be coded individually.
				• There is no separation of business logic, input logic, and the user interface.
		Overview of Web Forms:
			ASP.NET 4.x provides a wide variety of highly-functional controls that you assemble on Web Forms:
				• Input controls, such as text boxes, option buttons, and check boxes.
				• Display controls, such as image boxes, image maps, and ad rotators.
				• Data display controls, such as grid views, form views, and charts.
				• Validation controls, which check data entered by the user.
				• Navigation controls, such as menus and tree views.
			Web Forms Code Files:
				• page markup and code-behind file (example Default.aspx + Default.aspx.cs)
				• control markup and code-behind file (example CustomControl.ascx + CustomControl.ascx.cs)
			Binding Controls to Data:
				bind controls to data sources
			The Web Forms programming model has the following advantages:
				• You can design your page visually by using server controls and the Design view.
				• You can use a broad range of highly functional controls that encapsulate a lot of functionality.
				• You can display data without writing many lines of server-side code.
				• The user interface in the .aspx file is separated from input and business logic in the code-behind files.
			Using a Web Forms site has some disadvantages:
				• The page lifecycle is an abstraction layer over HTTP and can behave in unexpected ways. You must have a complete understanding of this life cycle, to write code in the correct event handlers.
				• You do not have precise control over the markup generated by the server-side controls.
				• Controls can add large amounts of markup and state information to the rendered HTML page. This increases the time taken to load pages.
		Overview of MVC:
			Strong separation of business logic, data access code, and the user interface into models, controllers, and views.
			Models:
				A model contains application business logic, validation, and database access logic. Each website presents information about different kinds of objects to site visitors. 
			Views:
				Views are markup pages that store both HTML and C# code in .cshtml files. This means that they are like Web Pages, but they include only user interface code. Other logic is separated into models and controllers.
			Controllers:
				Controllers respond to user actions, load data from a model, and pass it to a view so that it will render a webpage.
				Controllers are .NET classes that inherit from the System.Web.Mvc.Controller class and store code in .cs files.
				The MVC programming model has the following advantages:
					• Views enable the developer to take precise control of the HTML that is rendered.
					• You can use the Routing engine to take precise control of URLs.
					• Business logic, input logic, and user interface logic are separated into models, controllers, and views.
					• Unit testing techniques and Test Driven Development (TDD) are possible.
				Using an MVC site has some disadvantages:
					• MVC is potentially more complex to understand than Web Pages or Web Forms.
					• MVC forces you to separate your concerns (models, views, and controllers). Some programmers may find this challenging.
					• You cannot visually create a user interface by dragging controls onto a page.
					• You must have a full understanding of HTML, CSS, and JavaScript to develop views.
		Shared ASP.NET 4.x Features:
			The ASP.NET 4.x API:
				• Configuration:
					• Using the Web.config files, you can configure your web application, regardless of the programming model. The Web.config files are XML files with specific tags and attributes that the ASP.NET 4.x runtime accepts.
					• In code, you can access the configuration through the System.Web.Configuration namespace.
				• Authentication and Authorization:
					• You can use ASP.NET 4.x membership providers to authenticate and authorize users and restrict access to content. 
					• You can also build pages that enable users to register a new account, reset a password, recover a lost password, or perform other account management tasks. 
					• Membership providers belong to the System.Web.Security namespace.
				• Caching:
					• You can use caching to mitigate this delay. ASP.NET 4.x caches a rendered page in memory so that it can return the same page to subsequent user requests without having to render it again from the start. 
					• In a similar manner, .NET Framework objects can also be cached. 
					• You can access cached pages by using the System.Runtime.Caching namespace and configure the caches in Web.config.
			Compiling ASP.NET Code:
				Because ASP.NET 4.x server-side code uses .NET Framework, you must write code in a .NET managed programming language such as C# or Visual Basic. Before running the code, it must be compiled into native code so that the server CPU can process it. 
				This is a two-stage process:
					1. Compilation to MSIL. When you build a website in Visual Studio, the ASP.NET 4.x compiler creates .dll files with all the code compiled into Microsoft Intermediate Language (MSIL). This code is both independent of the language you used to write the application and the CPU architecture of the server.
					2. Compilation to native code. When a page is requested for the first time, the Common Language Runtime compiles MSIL into native code for the server CPU.
				This two-stage compilation process enables components written in different languages to work together and enables many errors to be detected at build time. 
				When you use the default compilation model, delays can arise when the first user requests a page. This is because ASP.NET 4.x must compile the page before serving it to the browser. To avoid such delays and to protect source code, use pre-compilation. When you pre-compile a site, all the ASP.NET 4.x files, including controllers, views, and models, are compiled into a single .dll file.
				Configuration:
					When you configure an ASP.NET 4.x site, you can control how errors are handled, how the site connects to databases, how user input is validated, and many other settings. You can configure ASP.NET 4.x sites by creating and editing the Web.config files. The Web.config file in the root folder of your site configures the entire site, but you can override this configuration at lower levels by creating Web.config files in sub-folders.
					Web.config files are XML files with a set of elements and attributes that the ASP.NET runtime accepts.
					If you need to access configuration values at runtime in your server-side .NET code, you can use the System.Web.Configuration namespace.
				Authentication:
					ASP.NET 4.x supports several mechanisms for authentication. 
					Integrated Windows Authentication mechanism uses your Windows user account to identify you. 
					Forms Authentication is supported by many browsers and it can be configured to check credentials against a database, directory service, or other user account stores.
				Membership and Roles:
					In ASP.NET 4.x, a membership provider is a component that implements user account management features. Several membership providers are supported by ASP.NET 4.x, such as the SQL membership provider, which uses a SQL database to store user accounts. You can also create a custom membership provider, inheriting from one of the default providers if you have unique requirements.
					When you have more than a few users, you may want to group them into roles with different levels of access. ASP.NET 4.x role providers enable you to create and populate roles with the minimum of custom code.
					You can enable access to pages on your website for individual user accounts or for all members of a role. This process is known as authorization.
				State Management:
					Web servers and web browsers communicate through HTTP. This is a stateless protocol in which each request is separate from requests before and after it. Any values from previous requests are not automatically remembered.
					However, when you build a web application, you must frequently preserve values across multiple page requests. ASP.NET 4.x provides several locations where you can store such values or state information across multiple requests.
				Caching:
					ASP.NET 4.x runtime on web server might run C# code that perform complex and time-consuming operations. It may run multiple queries against a database or call services on remote servers. You can mitigate these time delays by using ASP.NET 4.x caches.
					You can use the ASP.NET 4.x page cache to store the rendered version of a commonly requested page in the memory of the web server.
		Overview of Web API:
			Web API is an API that exists over the web and can be accessed using the HTTP protocol.
			Web API also allows you to implement REST services in your application and with that reduce application overhead and limit the data that is transmitted between client and server systems. 
			Web API allows you to call methods it exposes by using the server-side or client-side code and it allows you to implement REST-style Web APIs in your application.
			Call a Web API using AJAX:
				• JavaScript. Allows you to perform AJAX calls using the XMLHttpRequest object or the fetch method.
				• jQuery. Simplifies the process of writing AJAX calls by using the $.ajax method or other methods available in jQuery such as $.get or $.post.
				• Angular. Has dedicated objects for performing AJAX calls.
			The Web API programming model has the following advantages:	
				• Helps in creating RESTful APIs.
				• Enables external systems to use your application's business logic and features.
				• Can be accessed by various HTTP clients such as Windows, Android, IOs, and more.
				• Helps obtain data in different formats such as JSON, XML, and custom formats.
				• Supports create, read, update and delete (CRUD) actions since it works with HTTP verbs such as GET, POST, PUT, and DELETE.
				• Is ideal for mobile application integration.
			Using Web API has some disadvantages:
				• With Web API you have a complete separation between server-side code and client-side code. For some programmers, this is an advantage, but others may find this challenging and hard to understand.
				• The data returned from Web API usually is not indexed by search engines such as Google, more work needs to be done to make it crawlable.
	Lesson 3: Introduction to ASP.NET Core MVC
		Introduction to ASP.NET Core:
			ASP.NET Core is a cross-platform, open-source framework that allows you to create and host dynamic, powerful, and extensible web-based applications. With ASP.NET Core you can develop on various platforms – Windows, macOS, and Linux, deploy your application to the cloud, and create services and mobile backends.
			Why should you use ASP.NET Core?
				ASP.NET Core is a redesign of ASP.NET 4.x and it brings in many architectural shifts. ASP.NET Core is much leaner and modular than ASP.NET 4.x and has many changes within it.
				ASP.NET Core includes three main programming models that can help you to develop your applications smoothly:
					• MVC: 
						When you build a website using ASP.NET Core MVC, you separate your code into three parts: model, view, and controller. This separation of model, view, and controller code ensures that MVC applications have a logical structure, even for the most complex sites. It also improves the testability of the application.
					• Razor Pages:
						While in MVC we have a controller that receive requests, a model and a view that generates the response, with Razor Pages it is different. The request goes straight to a page that is generally located in the Pages folder.
						Each Razor Page file has an accompanying .cshtml.cs file that contains all the methods, model handlers, and logic. It contains a class that inherits from PageModel that will initialize the model inside the OnGet method. The OnGet method is also the place to get data from the database. Each public property inside the model can be displayed on the page using Razor syntax.
						What makes it different is the @page directive that must be at the first line of the .cshtml file. @page converts the file into a Razor Page, which means that it handles requests directly without going through a controller like in the MVC programming model.
						Razor syntax can be used inside Razor Pages. It allows you to insert the properties from the model and other sources into the HTML markup. Razor syntax starts with @ character. When you want to display properties from the model inside the HTML markup, you will use @model. @model will have a reference to the properties you initialized inside the OnGet method.
						The main difference between Razor Pages and MVC:
							In Razor Pages, the model and the controller are included in the Razor Pages classes and the request goes straight to the page. On the other hand, MVC programming model separates the code into models, views, and controllers.
					• Web API:
						• Controller. A Web API controller is a class that handles the client request that was sent to the server. It accesses the database, retrieves information, updates the database, if needed, and returns the HTTP response, including status code that indicates whether the action succeeded and data, if needed.
						• Model. As with MVC, it is a set of classes that represent the object types that the web application manages.
						• Client. The client sends requests to the server to run specific actions in the Web API controller. On the server side, there is an interface that consists of functions that can be accessed via HTTP. Those calls are sent from the client to the server to retrieve specific information and perform read-write operations.
		Choose between .NET Core and .NET Framework:
			.NET Standard:
				.NET Standard is a formal specification of the .NET APIs. It is intended to be available on all .NET implementations and its goal is to create a unification of the .NET ecosystem. It enables you to create code that is portable across all .NET implementations. Each .NET implementation is targeting a specific version of .NET Standard.
				A higher version number means that the previous versions are also supported but it has some extensions.
			When to use .NET Core for your application?
				You want your code to work cross-platform
				You want to create microservices
					In microservices architecture, the services layer is broken down into multiple independent components. A microservices architecture also allows you to create a mix of technologies across a service boundary.
				You want to use Docker containers (cross-platform, smaller size)
				You want to achieve a high-performing scalable system
			When to use .NET Framework for your application?
				You want to extend an existing application that uses .NET Framework (extend instead of migrate)
				You want to use NuGet packages or third-party .NET libraries that are not supported in .NET Core (not yet or not compatible)
				You want to use .NET technologies that aren't supported in .NET Core
				You want to use a platform that doesn’t support .NET Core.
		Models, Views, and Controllers:
			Models represent data and the accompanying business logic. Controllers interact with user requests and implement input logic. Views build the user interface.
			Models and Data:
				A model is a .NET class that represents an object handled by your website.
				Like any other .NET classes, model classes can include a constructor, which is a procedure that runs when a new instance of that class is created. You can also include other procedures, if necessary. These procedures encapsulate the business logic. 
				In an MVC application, the model includes code that reads and writes database records. ASP.NET Core MVC works with many different data access frameworks.
			Controllers and Actions:
				A controller is a .NET class that responds to web browser requests in an MVC application. There is usually one controller class for each model class. Controllers include actions, which are methods that run in response to a user request. 
				Controllers inherit from the Microsoft.AspNetCore.Mvc.Controller base class. Actions usually return an object that implements the Microsoft.AspNetCore.Mvc.IActionResult interface.
			Views and Razor:
				A view is a .cshtml file that includes both the HTML markup and programming code. A view engine interprets the view files, runs the server-side code, and renders HTML to the web browser. Razor is the default view engine in ASP.NET Core MVC.
				@ symbol delimits server-side code
			Request Life Cycle:
				The Request life cycle comprises a series of events that happen when a web request is processed.

Module 2: Designing ASP.NET Core MVC Web Applications
	Lesson 1: Planning in the Project Design Phase
		Project Development Methodologies:
			Waterfall Model:
				• Feasibility analysis. In this phase, planners and developers study and determine the approaches and technologies that can be used to build the software application.
				• Requirement analysis. In this phase, planners and analysts interview the users, managers, administrators, and other stakeholders of the software application to determine their needs.
				• Application design. In this phase, planners, analysts, and developers record a proposed solution.
				• Coding and unit testing. In this phase, developers create the code and test the components that make up the system individually.
				• Integration and system testing. In this phase, developers integrate the components that they have built and test the system as a whole.
				• Deployment and maintenance. In this phase, developers and administrators deploy the solution so that users can start using the software application.
			Iterative Development Model:
				break the project into small parts, for each part perform activities related to all the stages of the waterfall model, testing at each stage to ensure quality, corrective actions at the end of each iteration, requirements are added at the end of each iteration, revisit planned efforts and schedule
			Prototyping Model:
				 few or meagerly defined business requirements, vague understanding of needs and how to solve them, simplified version of software application, seek feedback from stakeholders, used to define the detailed requirements, consensus on requirements after couple of iterations, complete solution is built and tested, can lead to a poorly-designed application, at no stage in the project clear focus on the overall architecture
			Agile Software Development Model:
				The waterfall model, the iterative development model, and the prototyping model are based on the premise that business requirements and other factors do not change from the beginning to the end of the project. In reality, this assumption is often invalid. Agile software development is a methodology designed to integrate changing circumstances and requirements throughout the development process.
				• Incremental development. Software is developed in rapid cycles that build on earlier cycles. Each iteration is thoroughly tested.
				• Emphasis on people and interactions. Developers write code based on what people do in their role, rather than what the development tools are good at.
				• Emphasis on working software. Instead of writing detailed design documents for stakeholders, developers write solutions that stakeholders can evaluate at each iteration to validate if it solves a requirement.
				• Close collaboration with customers. Developers discuss with customers and stakeholders on a day-to-day basis to check requirements.
			Extreme Programming:
				preliminary design phase is reduced to a minimum and developers focus on solving a few critical tasks, developers test the simplified solution and obtain feedback from stakeholders, feedback helps developers identify the detailed requirements, XP defines a user story for every user role, user story describes all the interactions that a user with a specific role might perform within the completed application, collection of all the user stories for all user roles describes the entire application, developers often work in pairs, one developer writes code and other developer reviews code to ensure that it uses simple solutions and adheres to best practices, TDD is a core practice in extreme programming
			Test Driven Development:
				developers write test code as their first task in a given iteration, after you define the tests, you write the component such that it will pass those tests
			Unified Modeling Language:
				industry standard notation to record the design of any application that uses object-oriented technology, often used for planning and documenting application architecture and components, across all project development methodologies
				• Behavior diagrams. These diagrams depict the behavior of users, applications, and application components.
				• Interaction diagrams. These diagrams are a subset of behavior diagrams that focus on the interactions between objects.
				• Structure diagrams. These diagrams depict the elements of an application that are independent of time. This means they do not change through the lifetime of the application.
		Gathering Requirements:
			• Functional requirements. They describe how the application behaves and responds to users. Functional requirements are often called behavioral requirements. They include:
				o User interface requirements. They describe how the user interacts with an application.
				o Usage requirements. They describe what a user can do with the application.
				o Business requirements. They describe how the application will fulfill business functions.
			• Technical requirements. They describe technical features of the application and relate to availability, security, or performance. These requirements are sometimes called non-functional or non-behavioral requirements.
			Usage Scenarios and Use Cases:
				A usage scenario is a specific real-world example, with names and suggested input values, of an interaction between the application and a user.
				A use case is similar to a usage scenario, but is more generalized. Use cases do not include user names or input values. They describe multiple paths of an interaction, which depends on what the user provides as input or other values. 
				By analyzing usage scenarios and use cases, you can identify functional requirements of all types.
			Agile Requirements Modeling:
				• Initial requirement modeling. In the initial design phase, developers identify and record a few broad use cases in an informal manner without complete details.
				• Just-in-time modeling. Before writing code that implements a use case, a developer discusses it with the relevant users. At this point, the developer adds complete details to the use case. In an agile development project, developers talk to users and other stakeholders at all times, and not just at the beginning and end of the project.
				• Acceptance testing. An acceptance test is a test that the application must pass for all the stakeholders to accept and sign off on the application. When you identify a functional requirement, you can also specify a corresponding acceptance test that must be run to ensure that the requirements are met.
			User Stories in Extreme Programming:
				developers perform even less functional requirement analysis at the beginning of the project compared with other development models, create user stories, instead of use cases or user scenarios
				User stories contain just the minimal details to enable developers to estimate the effort involved in developing the solution.
				Extreme programmers discuss each user story with stakeholders just before they write code to implement each user story.
		Planning the Database Design:
			Logical Modeling:
				A domain model diagram, also known as a conceptual data model, shows the high-level conceptual objects that your web application manages.
				The domain model does not include details of the properties of each concept, but shows the relationships between the concepts.
			Physical Database Structure:
				• Tables. These are the fundamental storage objects in a database. When you define a table, you need to specify the columns for that table. For each column, you must define a data type such as integer, string, usually the nvarchar type in Microsoft SQL Server, or date and time. You should also define the primary key for the table—the value of this column uniquely identifies each record and is essential for defining the relationships with records in other tables.
				• Views. These are common presentations of data in tables and are based on queries. For example, a view can join two tables, such as a products table and a stock levels table.
				• Stored procedures. These are common sequences of database operations that you define in the database. Some operations are complex and might involve a complex transformation of the data. You can define a stored procedure to implement such a complex routine.
				• Security. You need to consider how the web application will authenticate with the database server and how you will authorize access to each database table.
			Working with Database Administrators:
				in larger organizations or in projects where the database stores critical business information, there might be a dedicated team of database administrators
				DBAs are usually highly skilled in database design and administration, and it is their job to ensure data integrity based on the organization’s data storage policy
				DBAs are critical contributors in delivering the web application
			Database Design in Agile Development and Extreme Programming:
				In agile development and extreme programming, the database design changes throughout the project until deployment. Therefore, developers should be able to alter the database whenever necessary without consulting DBAs or complying with complex data policies.
		Planning for Distributed Applications:
			Distributed web applications often use a layered architecture:
				• Presentation layer. Components in this layer implement the user interface and presentation logic. If you are building an MVC web application, views and controllers make up your presentation layer.
				• Business logic layer. Components in this layer implement high-level business objects such as products, or customers. If you are building an MVC web application, models make up your business logic layer.
				• Data access layer. Components in this layer implement database access operations and abstract database objects, such as tables, from business objects. If you are building an MVC web application, models often make up both business logic and data access layers. However, with careful design and coding practices, it is possible to refactor code to separate these layers.
				• Database layer. The database itself.
			If you implement such a layered architecture in your web application, you can host each layer on separate servers.
			This approach has the following advantages:
				• You can specify server hardware that closely matches each role.
				• You can dedicate multiple servers to each role to ensure that failure of a single server does not cause an interruption in service.
				• Only the web servers must be on the perimeter network. Both middle-tier servers and database servers can be protected by two firewalls without direct access from the Internet.
				• Alternatively, you can host middle-tier layers and databases on a cloud service, such as Microsoft Azure.
			Communication Between Layers:
				When you run different layers on different servers, you must consider two factors:
				• How does each layer exchange information and messages?
				• How does each server authenticate and secure communications with other servers?
				The communication of information and security is performed in different ways between the various layers:
					• Between the browser and presentation layer web server. In any web application, the web browser, where the presentation layer runs, communicates with the web server by using Hypertext Transfer Protocol (HTTP). If authentication is required, it is often performed by exchanging plain text credentials. You can also use Secure Sockets Layer (SSL) to encrypt this sensitive communication.
					• Between the web server and the middle-tier server. The communication and security mechanisms used for communication between the web server and the middle-tier server depends on the technology that you use to build the business logic components. Two common technologies are Web API and Windows Communication Foundation (WCF).
					• Between the middle-tier server and database. The middle-tier server sends T-SQL queries to the database server, which authenticates against the database by using the required credentials. These are often included in the connection string.
		Planning State Management:
			In application development, the application state refers to the values and information that are maintained across multiple operations. HTTP is fundamentally a stateless protocol, which indicates that it has no mechanism to retain state information across multiple page requests. However, there are many scenarios, such as the following, which require state to be preserved:
				• User preferences. Some websites enable users to specify preferences. If this preference information is lost between page requests, users have to repeatedly apply the preference.
				• User identity. Some sites authenticate users to provide access to members-only content. If the user identity is lost between page requests, the user must re-enter the credentials on every page.
				• Shopping carts. If the content of a shopping cart is lost between page requests, the customer cannot buy anything from your web application.
			Client-Side State Storage:
				Use client-side state storage only for small amounts of data:
					• Cookies. Cookies are small text files that you can pass to the browser to store information. A cookie can be stored:
						o In the memory of the client computer, in which case, it preserves information only for a single user session.
						o On the hard disk drive of the client computer, in which case, it preserves information across multiple sessions.
					• Most browsers can store cookies only up to 4,096 bytes and permit only 20 cookies per website. Therefore, cookies can be used only for small quantities of data. Also, some users might disable cookies for privacy purposes, so you should not rely on cookies for critical functions.
					• Query strings. A query string is the part of the URL after the question mark and is often used to communicate form values and other data to the server. You can use the query string to preserve a small amount of data from one page request to another. All browsers support query strings, but some impose a limit of 2,083 characters on the URL length. You should not place any sensitive information in query strings because it is visible to the user, anyone observing the session, or anyone monitoring web traffic.
			Server-Side State Storage:
				The following locations store state information in server memory:
					• TempData. This is a state storage location that you can use in MVC applications to store values between one request and another. This information is preserved for a single request only and is designed to help maintain data across a webpage redirect.
					• Application state. This is a state storage location that you can use to store values for the lifetime of the application. The values stored in application state are shared among all users. Application state is not an appropriate place to store user-specific values, such as preferences, because if you store a preference in application state, all users share the same preference, instead of having their own unique value.
					• Session state. This is a state storage location that you can use to store information for the lifetime of a single browser session and values stored here are specific to a single user session; they cannot be accessed by other users. Session state is available for both authenticated users and anonymous users. By default, session state uses cookies to identify users, but you can configure ASP.NET to store session state without using cookies.
					• Database tables. If your site uses an underlying database, like most sites do, you can store state information in its tables. This is a good place to store large volumes of state data that cannot be placed in server memory or on the client computer.
		Planning Globalization and Localization:
			The process by which you make a web application available in multiple languages is called globalization or internationalization. 
			The process by which you make a web application available in a specific language and culture is called localization.
			Managing Browsers for Languages and Regions:
				There is an internationally-recognized set of language codes that specify a culture on the Internet. These codes are in two parts:
					1. The language.
					2. The region. This specifies regional variations within a language and affects spellings and formats.
				The preferred language that users choose is available as the language code in the HTTP header of the user’s browser. This is the value that you respond to, so as to globalize your site. Alternatively, you can provide a control, such as a drop-down list, in which users can choose their preferred language. This is a good example of a user-preference that you can store in the session state.
			Using Resource Files:
				A resource file is a simple dictionary of terms in a given language. For each term in the file, you need to specify a name, a value, and optionally, a comment. The file has an .resx extension. The file name also includes the language code that applies to the resources. Resource files can also have a neutral culture. This means that the file applies to any region in a given language. You should also create corresponding default resource files, without any language code in the file name.
			Using Separate Views:
				When you use separate views to globalize and localize a site, views are more readable, because most of the text and labels remain in the view file. However, you must create view files, which requires you or your team members to be proficient in the target language.
		Planning Accessible Web Applications:
			Users have different requirements depending on their abilities and disabilities.:
				• Users with low vision might use a standard browser, but they might increase text size with a screen magnifier so that they can read the content.
				• Profoundly blind users might use a browser with text-to-speech software or text-to-Braille hardware.
				• Color-blind users might have difficulty if color is used to highlight text.
				• Deaf users might not be able to access audio content.
				• Users with limited dexterity might find it difficult to click small targets.
				• Users with epilepsy might have seizures if presented with flashing content.
			You can ensure that your content is accessible to the broadest range of users by adhering to the following guidelines:
				• Do not rely on color differences to highlight text or other content.
				• Always provide equivalent alternative content for visual and auditory content.
				• Use markup and style sheets to separate content from structure and presentation code. This helps text interpretation software to render content to users without being confused by structural and presentation code. Apply the following best practices to display content on your webpage:
					o Avoid using tables to display the content. You should use tables only to present tabulated content. Tables can be used to render graphics and branding on a webpage, but in an accessible site, use positional style sheets to display content.
					o Avoid using nested tables. In a nested table, a table cell contains another table. These are particularly confusing to text readers because they read each table cell in a sequential order. The user is likely to become disoriented and unable to determine which cell is being read and what it means.
					o Avoid using images that include important text. Text readers cannot render text from within an image file. Instead, use markup to render this text.
	Lesson 2: Designing Models, Controllers and Views
		Designing Models:
			Identifying Model Classes and Properties:
				The use cases, usage scenarios, or user stories that you gathered during the analysis phase of the project should enable you to determine the model classes that you need to create. 
				Each model class has a range of properties.
			Using Diagrams:
				use diagrams to analyze the information your website manages and suggest a physical data model or database design for the site, use these diagrams to plan
			Relationships and Aggregates:
				Numbers at the ends of each link show whether the relationship is one-to-one, one-to-many, or many-to-many.
				Aggregates place further limits on the behavior of model classes and clarify relationships.
			Entity Framework:
				Entity Framework is an Object-Relational Mapping (ORM) framework for .NET Framework-based applications. An ORM framework links database tables and views to classes that a developer can program against, by creating instances or calling methods.
			Design in Agile and Extreme Programming:
				characterized by short design phases in which data models are not completed, simple design, with little detail, is created and developers fill in details as they build code by continuously discussing requirements with users and other stakeholders
		Designing Controllers:
			In an ASP.NET Core MVC web application, controllers are .NET Framework-based classes that inherit from the Microsoft.AspNetCore.Mvc.Controller base class. They implement input logic—this means that they receive input from the user in the form of HTTP requests and select both the correct model and the correct view to use, to formulate a response.
			Identify Controllers and Actions:
				In an ASP.NET Core MVC web application, there is usually one controller for each model class. If you follow the naming convention in your design, you can use the MVC default routing behavior to select the right controller for a request.
				However, for each controller there can be many actions—each action is implemented as a method in the controller and usually returns a view. You often require separate actions for the GET and POST HTTP request verbs. Similar to designing a model, you can identify the actions to write in each controller by examining the use cases you gathered during analysis. 
			Design in Agile and Extreme Programming:
				only make generalized plans for controllers during the design phase of an agile development or extreme programming project
		Designing Views:
			In an ASP.NET Core MVC web application, the user interface is created by building views. There is a many-to-one relationship between MVC controllers and views.
			As you plan views, you should also consider parts of the user interface that appear on all pages. You can place these user interface components in a layout to create a consistent look and feel across pages.
			Some user interface components do not appear on all pages, but are re-used on several pages. By creating a partial view or a view component, you can create a re-usable user interface element that can appear in many locations in this manner, without duplicating code.
			Design in Agile and Extreme Programming:
				do not design many parts of the user interface during the initial phases of agile development or extreme programming projects, design views in close consultation with users during the development phase, create the layout during the early iterations of the development phase of the project
		Information Architecture:
			When the information your web application manages is complex and multi-faceted, it is easy to present objects in a confusing way. Unless you think carefully about the way users expect information to be structured and how they expect to navigate to useful content, you might unintentionally create an unusable web application. During development, when you work with a limited amount of data, this confusion might not become apparent. Then, when real-world data is added to your database at the time of deploying to production, it becomes clear that the web application is confusing. You can avoid this eventuality by planning the information architecture.
			Information architecture is a logical structure for the objects your web application manages. You should design such architecture in a way that users can find content quickly without understanding any technical aspects of your web application.
			Planning a Logical Hierarchy:
				Presenting a Hierarchy in Navigation Controls:
					• Site Menus. Most websites have a main menu that presents the main areas of content. For simple web applications, the main menu might include a small number of static links. For larger web applications, when users click a site menu link, a submenu appears.
					• Tree Views. A tree view is a menu that shows several levels of information hierarchy. Usually, users can expand or collapse objects at each level, to locate the content they require. Tree views are useful for presenting complex hierarchies in navigable structures.
					• Breadcrumb Trails. A breadcrumb trail is a navigation control that shows the user where they are in the web application. Usually a breadcrumb trail shows the current pages and all the parent pages in the hierarchy, with the home page as the top level page. Breadcrumb trails enable you to understand how a page fits in with the information architecture shown in menus and tree views.
				Presenting a Hierarchy in URLs:
					You can increase the usability of your web application by reflecting the information architecture in the URLs, which the users see in the address bar of the web browser. In many web applications, URLs often include long and inscrutable information such as Globally Unique Identifiers (GUIDs) and long query strings with many parameters. Such URLs prevent users from manually formulating the address to an item, and these URLs are difficult to link to a page on your web application. Instead, URLs should be plain and comprehensible, to help users browse through your content.
					You can control the URLs that your ASP.NET web application uses, by configuring the ASP.NET routing engine.

Module 3: Configure Middleware and Services in ASP.NET Core
	Lesson 1: Configuring Middleware
		Application Startup:
			Startup class is used for configuring middleware, which is performed in the Configure method, and for configuring services, which is performed in the ConfigureServices method.
			As part of startup, the ConfigureServices method will be called first if it is present, before calling the Configure method, which may have dependencies on the services that were declared in ConfigureServices.
			The ConfigureServices Method:
				The ConfigureServices method is an optional method where services that will be injected during the application lifespan can be registered. 
				It can also be used to set up various additional configuration options for the application.
				The ConfigureServices method receives a parameter that implements the IServiceCollection interface. This parameter is used to add services to the application.
				Some services are predefined in the framework and will not need to be declared (ILogger, IHostingEnvironment, etc.).
			The Configure Method:
				The Configure method is where the middleware pipeline can be defined. It is possible to add both existing middleware, as well as custom ones. 
				The Configure method supports Dependency Injection, allowing us to inject any services that have been set up and use them inside the middleware logic. 
				In general, the Configure method is where the order of handling requests and responses is determined. 
		Middleware Fundamentals:
			Middleware allows us to add code to manipulate the request and response pipeline in ASP.NET Core applications. 
			Every middleware in the pipeline can interact with the provided request, and write to the response, creating the desired result.
			Middleware is intended to work in a pipeline with each item inspecting the request, performing an action, or a manipulation on the response object and on completing its run, either calling the next middleware in the pipeline or if appropriate for the scenario, short-circuiting the pipeline and sending the finalized response.
			Short-circuiting should be done whenever the handler deems the request ended:
				Scenarios where you may want to short circuit the request:
					• When you match the correct route for the request.
					• When an error has been discovered in the request.
					• When you want to prevent the default handler.
			Every single instance of middleware has access to an HTTPContext parameter from the Microsoft.AspNetCore.Http namespace.
			This parameter allows us to access and manipulate information regarding the current request and response, and to many other details such as the authentication details, the current user, and more:
				• The Request property allows us to investigate details about the request made to the server, including the Query property, which allows us to read the Path and Body properties from the query string as a collection of key-value pairs:
					• The Path property allows us to find the relative path within the application.
					• The Body property is data sent as part of the request body and more. 
				• The Response property allows us to manipulate the response which will be sent back to the client:
					• It allows us to write to it using the WriteAsync method, or alternatively allows us to directly manipulate the response Body, ContentType, or even manually set StatusCode. 
					• Setting the StatusCode allows us to return custom errors.
			Middleware always run in the order they are defined. Additionally, all middleware operate in sequence, and are of several potential types:
				• Use. Middleware added with Use, support a parameter named next, which is a reference to the next middleware in the pipeline. You can short-circuit the pipeline by not invoking next, although all Use middleware should preferably support at least one flow in which they call next.Invoke() to proceed to the next middleware in the pipeline.
				• Run. Unlike Use, the Run middleware will always be the final middleware in the pipeline. It does not support the next parameter, and any middleware appearing after it will never be called.
				• Map. A third variation is the Map middleware. It does not continue with the current pipeline, instead, if the relative path is matched to the Map middleware, it will continue down a new pipeline, which is provided as a delegate to the Map middleware. Note that since Map middleware creates its own pipeline it is not affected by the Run middleware which occurs after it and can support a call to Run at the end of its own pipeline.
			Order of Middleware:
				It is important to remember that middleware runs in the order in which they were added to the pipeline:
					• A Run middleware should always be present at the very end of the pipeline. All middleware defined after the Run middleware will never be run.
					• Every application should only have a single Run middleware inside a specific pipeline. Remember that by using Map you create a new pipeline, which means the Run middleware inside of a Map pipeline is separate from the main pipeline.
					• Whenever multiple middleware share the same condition, it is important to order them to handle the pipeline in the desired way and be mindful of the possibility of the pipeline being short-circuited.
		Working with Static Files:
			Default Static File Serving:
				By calling UseStaticFiles, the application will automatically match relative paths to files inside the wwwroot folder of the application and serve them as the response for the current request. 
				Any file placed outside the wwwroot folder, will not be served and will be ignored by the server.
				Serving Static Files from Outside the wwwroot:
					In some cases, you may want to serve static files from a different folder, rather than wwwroot. To do this, you will need to call the UseStaticFiles middleware with a StaticFileOptions parameter. 
					By setting the FileProvider property, you can assign PhysicalFileProvider, which allows you to choose a file path. All files under this path will then be served as if they were on wwwroot. 
					It is important to note, that this replaces wwwroot. If you wish to host static files on both, you will need to call UseStaticFiles twice. Once without parameters, and the second time with the StaticFileOptions parameter.
			Serving Files under a Separate Relative Path:
				Sometimes you may wish to group the static files under a separate relative path. This can be particularly useful to help avoid conflicts. 
				By doing this, you can ensure that a specific relative path is kept separate from the remaining middleware pathing logic. This can also be done by supplying static files with StaticFileOptions while supplying the RequestPath property. 
				The request path must always begin with a / character and can contain several hierarchies if you so wish. After doing this, to use the static files, the application relative path matches the request path and then it will check for a match in the remaining path later.
			Problems with Serving Static Files:
				Some drawbacks to using UseStaticFiles:
					• All files served by using UseStaticFiles will always be available, there is no way to require authorization for them, and they will be available to all users.
					• Files served from UseStaticFiles will potentially be able to reveal information about the application structure, as all of them and their paths are accessible.
					• Depending on the hosting operating system, these files may or may not be case sensitive.
				Therefore, it is important that any file you wish to protect should not be inside folders you are serving. In particular, any cs code, or cshtml pages (cshtml pages will be covered in Module 5, “Developing Views”) should never be placed under a folder designated for serving to the client.
	Lesson 2: Configuring Services
		Introduction to Dependency Injection:
			Dependency Injection is a technique by which it is possible to facilitate separation of concerns in the application. Normally, to utilize a class in the application, you will need to be able to also manage any classes it depends on. This can cause a situation where whenever you instantiate a class, you may need to pass along to it a large number of parameters, which are then used to instantiate the class and potentially instantiate additional classes it depends on.
			By implementing Dependency Injection, you are able to simplify the process and adopt a more loosely coupled approach. By explicitly defining interfaces you wish to work within the constructor, you are able to specify only the requirements for the current class and you don’t need to worry about any possible sub-dependencies or making any changes should any sub dependency code change.
			By default, ASP.NET Core uses a simple built-in Dependency Injector container, which gives us the support of constructor injection. You can use the IServiceProvider interface to interact with the container, and the most prominent interaction is through the ConfigureServices method of the Startup class, which allows you to register additional services that you wish to run throughout the application.
		Using the Startup Class to Configure Services:
			Injecting Custom Services:
				After creating a service, you will need to register it in the ConfigureServices method of the Startup class. This can be done by using the services parameter, which implements the IServiceCollection interface.
				This method exposes to us several methods that can be used to add the service to the Dependency Injection container. The main methods for adding custom services are AddSingleton, AddTransient, and AddScoped.
			Injecting System Services:
				AddMvc vs AddMvcCore:
					AddMvcCore contains only the very basic components required to run an ASP.NET Core MVC application and lacks several additional services that are used for various additional functionalities, such as Cross Site Scripting handling and the Razor View engine.
				Injecting Services into Other Services:
					To inject a service into another, all you require is to add a constructor within the service, with a parameter type matching the interface you want to instantiate. After this is done, inside the constructor you can perform whatever logic you need from the dependency, including storing it locally inside of the class.
			Services inside ConfigureServices can be registered in any order, unlike middleware, and are resolved by the Dependency Injection container:
				• Keep them in order of dependencies, as it can provide a quick visual reference to the order in which services will be raised.
				• Dependency Injection cannot help us resolve circular references, and they will cause the application to crash.
		Inject Services to Controllers:
			One of the places where you benefit the most from Dependency Injection in an ASP.NET Core MVC application is the controllers. In ASP.NET Core MVC, a controller is a class with one or more methods, which are referred to as actions, designed with the intention of receiving requests and formulating a response based on the request.
			Once you have the controller set up, you will be able to inject services through the constructor. This behaves in a similar way to Dependency Injection into services, where you can add support for a service by explicitly adding a reference to the interface inside the constructor. Inside the constructor, you will be able to save the instance for use in the specific methods.
			The built-in Dependency Injection container in ASP.NET Core does not support multiple constructors. Should the need arise to support multiple constructors alongside Dependency Injection, you will need to use a different dependency injector.
		Service Lifetime:
			correctly preserve service state in an application:
			If you keep all of the services in the application running constantly, you run the risk of creating deadlocks while dealing with external resources as well as potential issues with threading, as each singleton service is locked to one thread since it is first instantiated. 
			On the other hand, keeping all services completely stateless can deprive us of the ability to retain data temporarily and prevent us from being able to manage data correctly.
			AddSingleton:
				Tells the Dependency Injection container to create this service once and then to inject the same instance as long as the application remains running.
				Use it to handle data, which you want to persist inside the memory rather than in an external source (such as a database, file, or another source).
				Requires a service instance to persist throughout the entire application lifespan, helping to keep the same data consistent and persistent.
			AddScoped:
				 When a service is registered by using AddScoped, all instances where it is injected as a result of the current request being processed will receive the same instance. However, for any other request, a new instance will be created.
				 Use it to maintain data throughout the lifetime of a single request without affecting data for other requests.
				 Can be useful for dealing with particular parameters for the specific request such as query string parameters or data which is retrieved due to a specific request, such as user information relating to the user that made the request.
			AddTransient:
				Instantiated individually every time it’s injected, with each instance being completely separate from all others. Due to this, data should never be stored on a transient service.
				Use if for services that will end up being stateless and will not need to store data. 

Module 4: Developing Controllers
	Lesson 1: Writing Controllers and Actions
		TODO
	Lesson 2: Configuring Routes
		TODO
	Lesson 3: Writing Action Filters
		TODO

Module 5: Developing Views
	Lesson 1: Creating Views with Razor Syntax
		TODO
	Lesson 2: Using HTML Helpers and Tag Helpers
		TODO
	Lesson 3: Reusing Code in Views
		TODO

Module 6: Developing Models
	Lesson 1: Creating MVC Models
		TODO
	Lesson 2: Working with Forms
		TODO
	Lesson 3: Validating MVC Application
		TODO

Module 7: Using Entity Framework Core in ASP.NET Core
	Lesson 1: Introduction to Entity Framework Core
		TODO
	Lesson 2: Working with Entity Framework Core
		TODO
	Lesson 3: Using Entity Framework Core in ASP.NET Core
		TODO

Module 8: Using Layouts, CSS and JavaScript in ASP.NET Core MVC
	Lesson 1: Using Layouts
		TODO
	Lesson 2: Using CSS and JavaScript
		TODO
	Lesson 3: Using jQuery
		TODO

Module 9: Client-Side Development
	Lesson 1: Applying Styles
		TODO
	Lesson 2: Using Task Runners
		TODO
	Lesson 3: Responsive Design
		TODO

Module 10: Testing and Troubleshooting
	Lesson 1: Testing MVC Applications
		TODO
	Lesson 2: Implementing an Exception Handling Strategy
		TODO
	Lesson 3: Logging MVC Applications
		TODO

Module 11: Managing Security
	Lesson 1: Authentication in ASP.NET Core
		TODO
	Lesson 2: Authorization in ASP.NET Core
		TODO
	Lesson 3: Defending from Attacks
		TODO

Module 12: Performance and Communication
	Lesson 1: Implementing a Caching Strategy
		TODO
	Lesson 2: Managing State
		TODO
	Lesson 3: Two-Way Communication
		TODO

Module 13: Implementing Web APIs
	Lesson 1: Introducing Web APIs
		TODO
	Lesson 2: Developing a Web API
		TODO
	Lesson 3: Calling a Web API
		TODO

Module 14: Hosting and Deployment
	Lesson 1: On-Premises Hosting and Deployment
		TODO
	Lesson 2: Deployment to Microsoft Azure
		TODO
	Lesson 3: Microsoft Azure Fundamentals
		TODO